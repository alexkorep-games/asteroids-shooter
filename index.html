<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Asteroid Shooter</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        /* cursor: none; /* Manage cursor visibility in JS */
        font-family: "Consolas", "Courier New", monospace; /* Pixel-like font */
        background-color: #000; /* Ensure body bg for contrast */
      }
      canvas {
        display: block;
      }
      #instructions {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: sans-serif;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px;
        border-radius: 3px;
        display: none;
        z-index: 10;
      }
      #gameOverScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8); /* Darker overlay */
        color: white;
        font-family: "Consolas", "Courier New", monospace; /* Match font */
        display: none; /* Initially hidden */
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 20;
        cursor: default; /* Show default cursor over the overlay */
        padding: 20px;
        box-sizing: border-box;
      }
      #gameOverScreen h1 {
        margin-bottom: 15px;
        font-size: 3em;
        color: #ff4d4d; /* Red Game Over text */
        text-shadow: 2px 2px #a00;
      }
      #finalScore {
        font-size: 1.5em;
        margin-bottom: 25px;
        color: #eee;
      }
      #restartButton {
        padding: 12px 25px;
        font-size: 1.3em;
        cursor: pointer; /* Pointer specifically for the button */
        border: 2px solid #ccc;
        border-radius: 5px;
        background-color: #333; /* Darker button */
        color: #eee;
        margin-top: 30px; /* Space above button */
        font-family: "Consolas", "Courier New", monospace;
        transition: background-color 0.2s, color 0.2s;
      }
      #restartButton:hover {
        background-color: #eee;
        color: #333;
      }

      /* --- High Score Table Styles --- */
      #highScoreContainer {
        margin-top: 30px;
        background-color: rgba(20, 20, 20, 0.7);
        padding: 15px 25px;
        border-radius: 8px;
        border: 1px solid #555;
        max-width: 350px;
        width: 80%;
      }
      #highScoreContainer h2 {
        margin-top: 0;
        margin-bottom: 15px;
        color: #0f0; /* Greenish title */
        font-size: 1.4em;
        text-decoration: underline;
      }
      #highScoreList {
        list-style-type: decimal; /* Numbered list */
        padding-left: 30px; /* Indent numbers */
        margin: 0;
        text-align: left;
        font-size: 1.1em;
        max-height: 150px; /* Limit height */
        overflow-y: auto; /* Scroll if needed */
        color: #ddd;
      }
      #highScoreList li {
        margin-bottom: 5px;
      }
      #highScoreList .loading,
      #highScoreList .error {
        font-style: italic;
        color: #aaa;
        text-align: center;
        list-style: none; /* Remove bullet for status messages */
      }

      /* --- HUD Styles --- */
      #hud {
        position: absolute;
        top: 15px;
        left: 15px;
        right: 15px;
        display: flex;
        justify-content: space-between;
        align-items: flex-start; /* Align items to the top */
        pointer-events: none; /* Allow clicking through HUD */
        z-index: 15;
        color: white;
        font-family: "Consolas", "Courier New", monospace; /* Consistent font */
      }

      #healthContainer {
        display: flex;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.5);
        padding: 5px 8px;
        border-radius: 4px;
        border: 1px solid rgba(255, 255, 255, 0.3);
      }

      #healthIcon {
        width: 20px; /* Adjust size as needed */
        height: 20px;
        margin-right: 8px;
        /* Placeholder: Use an actual heart image/icon later */
        position: relative;
        font-size: 18px; /* Adjust emoji size */
        line-height: 20px; /* Align emoji vertically */
      }

      #healthBarOuter {
        width: 150px; /* Adjust width as needed */
        height: 15px;
        background-color: #444;
        border: 1px solid #666;
        border-radius: 3px;
        overflow: hidden; /* Ensure inner bar stays within bounds */
        /* margin-top: 2px; /* Align slightly better with icon */
      }

      #healthBarInner {
        height: 100%;
        width: 100%; /* Initial full health */
        background-color: #4caf50; /* Green */
        transition: width 0.3s ease, background-color 0.3s ease; /* Smooth transition for health loss */
      }

      #asteroidCounter {
        position: absolute; /* Position independently */
        bottom: 20px;
        right: 20px;
        background-color: rgba(0, 0, 0, 0.5);
        padding: 8px 12px;
        border-radius: 4px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        font-size: 1.2em;
        color: #eee;
        z-index: 15;
        text-align: right;
        font-family: "Consolas", "Courier New", monospace;
      }
      #speedIndicator {
        position: absolute; /* Position independently */
        bottom: 20px; /* Same distance from bottom as asteroid counter */
        left: 20px; /* Position on the left */
        background-color: rgba(0, 0, 0, 0.5);
        padding: 8px 12px;
        border-radius: 4px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        font-size: 1.2em; /* Slightly smaller than asteroid count? Adjust as needed */
        color: #eee;
        z-index: 15;
        pointer-events: none; /* Allow clicking through */
        font-family: "Consolas", "Courier New", monospace; /* Match other HUD text */
      }

      /* --- End HUD Styles --- */
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>

    <!-- HUD Elements -->
    <div id="hud">
      <div id="healthContainer">
        <div id="healthIcon">‚ù§Ô∏è</div>
        <div id="healthBarOuter">
          <div id="healthBarInner"></div>
        </div>
      </div>
    </div>
    <div id="speedIndicator">üöÄ 0.0 m/sec</div>
    <div id="asteroidCounter">0 / 0 ‚òÑÔ∏è</div>

    <div id="instructions">Loading assets...</div>

    <div id="gameOverScreen">
      <h1>Game Over</h1>
      <div id="finalScore">Final Score: 0</div>
      <!-- Added Final Score Display -->

      <!-- High Score Section -->
      <div id="highScoreContainer">
        <h2>Global Records</h2>
        <ol id="highScoreList">
          <li class="loading">Loading scores...</li>
          <!-- Scores will be populated here -->
        </ol>
      </div>
      <!-- End High Score Section -->

      <button id="restartButton">Restart Game</button>
    </div>

    <!-- ES Module Shims -->
    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <!-- Import Map -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.156.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.156.1/examples/jsm/",
          "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js",
          "firebase/app": "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js",
          "firebase/database": "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js"
        }
      }
    </script>

    <!-- Main Game Script -->
    <script type="module">
      import * as THREE from "three";
      import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
      import { createNoise3D } from "simplex-noise";
      // Import Firebase modules
      import { initializeApp } from "firebase/app";
      import {
        getDatabase,
        ref,
        push,
        serverTimestamp,
        query,
        orderByChild,
        limitToLast,
        get,
        remove,
        onValue, // Optional: for real-time updates if desired
      } from "firebase/database";

      // --- Firebase Configuration ---
      const firebaseConfig = {
        apiKey: "AIzaSyBoO3ZOL4QqxxtcyT4UDK9F09VjjBqXCQA",
        authDomain: "retroglide.firebaseapp.com",
        databaseURL:
          "https://retroglide-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "retroglide",
        storageBucket: "retroglide.firebasestorage.app",
        messagingSenderId: "791505722362",
        appId: "1:791505722362:web:9b72f63d1bf3ee1740a243",
      };

      // Initialize Firebase
      let firebaseApp;
      let database;
      let highScoresRef;
      const HIGH_SCORE_COUNT = 10; // Number of scores to display/keep

      try {
        firebaseApp = initializeApp(firebaseConfig);
        database = getDatabase(firebaseApp);
        highScoresRef = ref(database, "highscores"); // Path in your database
        console.log("Firebase initialized successfully.");
      } catch (error) {
        console.error("Firebase initialization failed:", error);
        // Optionally display an error to the user
        // You could disable high score functionality here
        database = null; // Ensure database operations fail gracefully later
      }

      // --- Game Constants ---
      // (Keep existing constants)
      const ASTEROID_SPAWN_RATE = 3;
      const INITIAL_ASTEROID_SPEED = 20.0;
      const ASTEROID_SCALE_MIN = 0.4;
      const ASTEROID_SCALE_MAX = 1.2;
      const ASTEROID_BASE_RADIUS = 1.0;
      const ASTEROID_DESTRUCTION_DURATION = 0.2;
      const ASTEROID_FLASH_COLOR = new THREE.Color(0xffffff);

      const PLAYER_SMOOTHING = 0.08;
      const SHIP_DEPTH = 0;
      const SPAWN_DISTANCE = 140;
      const DESPAWN_DISTANCE = 0;
      const MAX_ASTEROIDS = 50;
      const MOVEMENT_RATIO = 2.0;
      const SHIP_COLLISION_RADIUS_FACTOR = 0.4;
      const SHIP_INITIAL_HEALTH = 100;
      const SHIP_COLLISION_DAMAGE = 10;
      const INVULNERABILITY_DURATION = 1.5;

      const PROJECTILE_SPEED = 100.0;
      const PROJECTILE_RADIUS = 0.1;
      const SHOT_COOLDOWN = 0.15;
      const MAX_PROJECTILES = 30;
      const PROJECTILE_DESPAWN_Z = -130;

      // --- Three.js Setup ---
      const renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById("c"),
        antialias: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 5;

      scene.add(new THREE.AmbientLight(0xffffff, 1));
      const dirLight = new THREE.DirectionalLight(0xffffff, 20.8);
      dirLight.position.set(5, 8, 7);
      scene.add(dirLight);

      const clock = new THREE.Clock();

      // --- Game State Variables ---
      let playerShip = null;
      const asteroids = [];
      const projectiles = [];
      let targetShipPosition = new THREE.Vector3(0, -1, SHIP_DEPTH);
      const mouseNDC = new THREE.Vector2();

      let isTouching = false;
      let isShooting = false;
      let touchStartPos = new THREE.Vector2();
      let touchStartShipPos = new THREE.Vector3();
      let timeSinceLastShot = 0;
      let timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE;

      let isGameOver = false;
      let animationFrameId = null;
      let shipBoundingSphere = null;
      let playerHealth = SHIP_INITIAL_HEALTH;
      let asteroidsDestroyed = 0;
      let totalAsteroidsSpawned = 0;
      let isInvulnerable = false;
      let invulnerabilityTimer = 0;
      let shipFlashToggle = false;
      let shipOriginalMaterial = null;
      let asteroidSpeed = INITIAL_ASTEROID_SPEED;

      // --- DOM Elements ---
      const instructionsDiv = document.getElementById("instructions");
      const gameOverScreen = document.getElementById("gameOverScreen");
      const restartButton = document.getElementById("restartButton");
      const healthBarInner = document.getElementById("healthBarInner");
      const asteroidCounterDisplay = document.getElementById("asteroidCounter");
      const speedIndicatorDisplay = document.getElementById("speedIndicator");
      const finalScoreDisplay = document.getElementById("finalScore"); // New
      const highScoreList = document.getElementById("highScoreList"); // New

      // --- Loaders ---
      const loadingManager = new THREE.LoadingManager();
      const fbxLoader = new FBXLoader(loadingManager);
      const textureLoader = new THREE.TextureLoader(loadingManager);

      // --- Initialization ---
      instructionsDiv.style.display = "block";
      document.body.style.cursor = "none";

      // Load Background
      textureLoader.load(
        "./assets/background.png",
        (texture) => {
          scene.background = texture;
        },
        undefined,
        (error) => {
          console.error("Error loading background texture:", error);
          instructionsDiv.innerText = `Error loading background: assets/background.png. Check path/file.`;
          instructionsDiv.style.color = "red";
        }
      );

      // Load Ship Model
      fbxLoader.load(
        "./assets/Galactic_Soarer_0504175114_texture.fbx",
        (fbx) => {
          playerShip = fbx;
          playerShip.scale.setScalar(0.02);
          playerShip.rotation.x = Math.PI * 0.05;
          playerShip.position.set(
            targetShipPosition.x,
            targetShipPosition.y,
            SHIP_DEPTH
          );
          scene.add(playerShip);

          playerShip.traverse((child) => {
            if (child.isMesh && !shipOriginalMaterial) {
              shipOriginalMaterial = child.material;
            }
          });

          const box = new THREE.Box3().setFromObject(playerShip, true);
          shipBoundingSphere = new THREE.Sphere();
          box.getBoundingSphere(shipBoundingSphere);
          shipBoundingSphere.radius *= SHIP_COLLISION_RADIUS_FACTOR;
        },
        (xhr) => {
          const percentLoaded = (xhr.loaded / xhr.total) * 100;
          if (
            !scene.background &&
            !instructionsDiv.innerText.startsWith("Error")
          ) {
            instructionsDiv.innerText = `Loading ship: ${Math.round(
              percentLoaded
            )}%`;
          }
        },
        (error) => {
          console.error("Error loading FBX model:", error);
          instructionsDiv.innerText = `Error loading ship: ${shipModelPath}. Check path and console.`;
          instructionsDiv.style.color = "red";
        }
      );

      // Projectile Assets
      const projectileGeometry = new THREE.SphereGeometry(
        PROJECTILE_RADIUS,
        8,
        8
      );
      const projectileMaterial = new THREE.MeshBasicMaterial({
        color: 0xffff00,
      }); // Yellow projectiles

      loadingManager.onLoad = () => {
        if (!instructionsDiv.innerText.startsWith("Error")) {
          instructionsDiv.style.display = "none";
        }
        setupInputListeners();
        restartButton.addEventListener("click", restartGame);
        startGame();
      };

      loadingManager.onError = (url) => {
        console.error("There was an error loading " + url);
      };

      // --- Firebase High Score Functions ---

      async function saveHighScore(score) {
        if (!database || !highScoresRef || score <= 0) {
          console.log("Database not available or score is zero, not saving.");
          return; // Don't save if Firebase isn't initialized or score is 0
        }

        try {
          // 1. Push the new score
          const newScore = {
            score: score,
            timestamp: serverTimestamp(), // Use server timestamp for consistency
          };
          await push(highScoresRef, newScore);
          console.log("Score potentially saved:", score);

          // 2. Trim the leaderboard (keep only the top HIGH_SCORE_COUNT)
          // Fetch all scores, ordered by score ascending
          const scoresQuery = query(highScoresRef, orderByChild("score"));
          const snapshot = await get(scoresQuery);

          if (snapshot.exists()) {
            const scores = [];
            snapshot.forEach((childSnapshot) => {
              scores.push({ key: childSnapshot.key, ...childSnapshot.val() });
            });

            // If we have more scores than allowed, remove the lowest ones
            if (scores.length > HIGH_SCORE_COUNT) {
              const scoresToRemove = scores.length - HIGH_SCORE_COUNT;
              for (let i = 0; i < scoresToRemove; i++) {
                const keyToRemove = scores[i].key;
                await remove(ref(database, `highscores/${keyToRemove}`));
                console.log(`Removed low score entry: ${keyToRemove}`);
              }
            }
          }
        } catch (error) {
          console.error("Error saving or trimming high score:", error);
        }
      }

      async function fetchAndDisplayHighScores() {
        if (!database || !highScoresRef) {
          highScoreList.innerHTML =
            '<li class="error">High score service unavailable.</li>';
          return;
        }

        highScoreList.innerHTML = '<li class="loading">Loading scores...</li>'; // Show loading state

        try {
          // Fetch the TOP N scores (limitToLast retrieves the highest when ordered by score)
          const scoresQuery = query(
            highScoresRef,
            orderByChild("score"),
            limitToLast(HIGH_SCORE_COUNT)
          );
          const snapshot = await get(scoresQuery);

          if (snapshot.exists()) {
            const scores = [];
            snapshot.forEach((childSnapshot) => {
              scores.push(childSnapshot.val());
            });

            // Reverse sort because limitToLast gives them potentially lowest-to-highest within the top N
            scores.sort((a, b) => b.score - a.score);

            highScoreList.innerHTML = ""; // Clear loading/previous scores
            if (scores.length === 0) {
              highScoreList.innerHTML =
                '<li class="loading">No scores yet!</li>';
            } else {
              scores.forEach((scoreData, index) => {
                const li = document.createElement("li");
                // You could add timestamp formatting here if needed:
                // const date = new Date(scoreData.timestamp);
                // li.textContent = `${index + 1}. ${scoreData.score} pts (${date.toLocaleDateString()})`;
                li.textContent = `${index + 1}. ${scoreData.score} pts`;
                highScoreList.appendChild(li);
              });
            }
          } else {
            highScoreList.innerHTML = '<li class="loading">No scores yet!</li>';
          }
        } catch (error) {
          console.error("Error fetching high scores:", error);
          highScoreList.innerHTML =
            '<li class="error">Could not load scores.</li>';
        }
      }

      // --- Utility Functions ---
      // (Keep makeAsteroid, markAsteroidAsDying, updateSpeed, disposeObject)
      function makeAsteroid() {
        const RADIUS = ASTEROID_BASE_RADIUS;
        const SEGMENTS = 8;
        const geometry = new THREE.SphereGeometry(RADIUS, SEGMENTS, SEGMENTS);
        const noise3D = createNoise3D();
        const posAttr = geometry.attributes.position;
        const v = new THREE.Vector3();
        const OCTAVES = 3,
          BASE_FREQ = 1.4,
          BASE_AMP = 0.18;

        for (let i = 0; i < posAttr.count; i++) {
          v.fromBufferAttribute(posAttr, i).normalize();
          let n = 0,
            amp = 1,
            freq = BASE_FREQ;
          for (let o = 0; o < OCTAVES; o++) {
            n += amp * noise3D(v.x * freq, v.y * freq, v.z * freq);
            amp *= 0.5;
            freq *= 2.0;
          }
          v.multiplyScalar(RADIUS + n * BASE_AMP);
          posAttr.setXYZ(i, v.x, v.y, v.z);
        }
        posAttr.needsUpdate = true;
        geometry.computeVertexNormals();
        geometry.computeBoundingSphere();

        const mainMaterial = new THREE.MeshToonMaterial({
          color: 0xdd44aa,
          emissive: 0x110011,
          // flatShading: true,
        });
        const mainAsteroid = new THREE.Mesh(geometry, mainMaterial);
        mainAsteroid.userData.originalColor = mainMaterial.color.clone();

        const outlineMaterial = new THREE.MeshBasicMaterial({
          color: 0x220022,
          side: THREE.BackSide,
        });
        const outlineMesh = new THREE.Mesh(geometry.clone(), outlineMaterial);
        const OUTLINE_SCALE = 1.06;
        outlineMesh.scale.set(OUTLINE_SCALE, OUTLINE_SCALE, OUTLINE_SCALE);
        mainAsteroid.add(outlineMesh);
        outlineMesh.userData.originalColor = outlineMaterial.color.clone();

        const velocity = new THREE.Vector3(0, 0, 1)
          .normalize()
          .multiplyScalar(asteroidSpeed);

        mainAsteroid.userData = {
          ...mainAsteroid.userData,
          velocity: velocity,
          rotationSpeed: new THREE.Vector3(
            THREE.MathUtils.randFloat(-0.5, 0.5),
            THREE.MathUtils.randFloat(-0.5, 0.5),
            THREE.MathUtils.randFloat(-0.5, 0.5)
          ),
          boundingRadius: geometry.boundingSphere.radius,
          isAsteroid: true,
          isDying: false,
          dyingTimer: 0,
          originalScale: 1.0,
        };
        return mainAsteroid;
      }

      function markAsteroidAsDying(asteroid) {
        if (!asteroid || asteroid.userData.isDying) return; // Already dying

        asteroid.userData.isDying = true;
        asteroid.userData.dyingTimer = ASTEROID_DESTRUCTION_DURATION;
        // Store original scale if not already stored (should be set at spawn)
        if (asteroid.userData.originalScale === undefined) {
          asteroid.userData.originalScale = asteroid.scale.x;
        }

        // Flash Effect
        if (asteroid.material) {
          asteroid.material.color.copy(ASTEROID_FLASH_COLOR);
          asteroid.material.emissive.copy(ASTEROID_FLASH_COLOR);
        }
        if (asteroid.children[0] && asteroid.children[0].material) {
          asteroid.children[0].material.color.copy(ASTEROID_FLASH_COLOR);
        }

        // Increment counter only when an asteroid is marked for dying
        asteroidsDestroyed++;
        updateSpeed();
        updateUI(); // Update the counter display
      }

      function updateSpeed() {
        // Increase speed based on the number of asteroids destroyed
        asteroidSpeed = INITIAL_ASTEROID_SPEED + asteroidsDestroyed * 1.5;
        // Update velocity for NEWLY spawned asteroids (existing ones keep their speed)
      }

      function disposeObject(obj) {
        if (!obj) return;
        if (obj.parent) obj.parent.remove(obj);
        else if (scene.children.includes(obj)) scene.remove(obj);

        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)) {
            obj.material.forEach((material) => {
              if (material.map) material.map.dispose();
              material.dispose();
            });
          } else {
            if (obj.material.map) obj.material.map.dispose();
            obj.material.dispose();
          }
        }
        while (obj.children.length > 0) {
          disposeObject(obj.children[0]);
        }
      }

      function updateUI() {
        // Update Health Bar
        const healthPercentage = Math.max(0, playerHealth); // Clamp at 0
        healthBarInner.style.width = healthPercentage + "%";

        if (healthPercentage <= 25) {
          healthBarInner.style.backgroundColor = "#ff4d4d"; // Red
        } else if (healthPercentage <= 50) {
          healthBarInner.style.backgroundColor = "#ffcc00"; // Yellow
        } else {
          healthBarInner.style.backgroundColor = "#4CAF50"; // Green
        }

        // Update Asteroid Counter
        asteroidCounterDisplay.textContent = `${asteroidsDestroyed}/${totalAsteroidsSpawned} ‚òÑÔ∏è`;
        // Update Speed Indicator
        speedIndicatorDisplay.textContent = `üöÄ ${asteroidSpeed.toFixed(
          1
        )} m/sec`;
      }

      // --- Input Handling ---
      function setupInputListeners() {
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("mousedown", onMouseDown);
        window.addEventListener("mouseup", onMouseUp);
        window.addEventListener("touchstart", onTouchStart, { passive: false });
        window.addEventListener("touchmove", onTouchMove, { passive: false });
        window.addEventListener("touchend", onTouchEnd);
        window.addEventListener("touchcancel", onTouchEnd);
      }
      function screenToWorld(clientX, clientY) {
        const screenNDC = new THREE.Vector2();
        screenNDC.x = (clientX / window.innerWidth) * 2 - 1;
        screenNDC.y = -(clientY / window.innerHeight) * 2 + 1;
        const vector = new THREE.Vector3(screenNDC.x, screenNDC.y, 0.5);
        vector.unproject(camera);
        const dir = vector.sub(camera.position).normalize();
        const distance = (SHIP_DEPTH - camera.position.z) / dir.z;
        const worldPos = new THREE.Vector3();
        worldPos.copy(camera.position).add(dir.multiplyScalar(distance));
        return worldPos;
      }
      function getVisibleWidth() {
        return getVisibleHeight() * camera.aspect;
      }
      function getVisibleHeight() {
        return (
          2 *
          Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) *
          Math.abs(SHIP_DEPTH - camera.position.z)
        );
      }
      function clampTargetShipPosition() {
        const visibleHeight = getVisibleHeight();
        const visibleWidth = getVisibleWidth();
        targetShipPosition.x = THREE.MathUtils.clamp(
          targetShipPosition.x,
          -visibleWidth / 2.2,
          visibleWidth / 2.2
        );
        targetShipPosition.y = THREE.MathUtils.clamp(
          targetShipPosition.y,
          -visibleHeight / 2.2,
          visibleHeight / 2.2
        );
        targetShipPosition.z = SHIP_DEPTH;
      }
      function updateTargetPositionFromScreenCoords(clientX, clientY) {
        mouseNDC.x = (clientX / window.innerWidth) * 2 - 1;
        mouseNDC.y = -(clientY / window.innerHeight) * 2 + 1;
        const vector = new THREE.Vector3(mouseNDC.x, mouseNDC.y, 0.5);
        vector.unproject(camera);
        const dir = vector.sub(camera.position).normalize();
        const distance = (SHIP_DEPTH - camera.position.z) / dir.z;
        targetShipPosition
          .copy(camera.position)
          .add(dir.multiplyScalar(distance));
        clampTargetShipPosition();
      }
      function onMouseMove(event) {
        if (isGameOver) return;
        updateTargetPositionFromScreenCoords(event.clientX, event.clientY);
      }
      function onMouseDown(event) {
        if (isGameOver) return;
        if (event.button === 0) isShooting = true;
      }
      function onMouseUp(event) {
        if (event.button === 0) isShooting = false;
      }
      function onTouchStart(event) {
        if (isGameOver) return;
        event.preventDefault();
        isShooting = true;
        if (event.touches.length === 1 && !isTouching) {
          isTouching = true;
          const touch = event.touches[0];
          touchStartPos.set(touch.clientX, touch.clientY);
          if (playerShip) touchStartShipPos.copy(playerShip.position);
          else touchStartShipPos.copy(targetShipPosition);
        }
      }
      function onTouchMove(event) {
        if (isGameOver) return;
        event.preventDefault();
        if (isTouching && event.touches.length > 0) {
          const touch = event.touches[0];
          const currentTouchPos = new THREE.Vector2(
            touch.clientX,
            touch.clientY
          );
          const worldStartPos = screenToWorld(touchStartPos.x, touchStartPos.y);
          const worldCurrentPos = screenToWorld(
            currentTouchPos.x,
            currentTouchPos.y
          );
          const worldDelta = worldCurrentPos.sub(worldStartPos);
          targetShipPosition
            .copy(touchStartShipPos)
            .addScaledVector(worldDelta, MOVEMENT_RATIO);
          clampTargetShipPosition();
        }
      }
      function onTouchEnd(event) {
        if (event.touches.length === 0) {
          isShooting = false;
          isTouching = false;
        } else {
          let movementTouchStillActive = false;
          for (let i = 0; i < event.touches.length; i++) {
            movementTouchStillActive = true;
            break;
          }
          if (!movementTouchStillActive) isTouching = false;
          isShooting = true;
        }
      }

      // --- Spawning ---
      function spawnAsteroid() {
        if (asteroids.length >= MAX_ASTEROIDS) return;
        const asteroid = makeAsteroid();
        totalAsteroidsSpawned++;
        updateUI();
        const spawnZ = camera.position.z - SPAWN_DISTANCE;
        const height = getVisibleHeight() / 2.2;
        const width = getVisibleWidth() / 2.2;
        asteroid.position.set(
          THREE.MathUtils.randFloatSpread(width),
          THREE.MathUtils.randFloatSpread(height),
          spawnZ
        );
        const scale = THREE.MathUtils.randFloat(
          ASTEROID_SCALE_MIN,
          ASTEROID_SCALE_MAX
        );
        asteroid.scale.setScalar(scale);
        asteroid.userData.originalScale = scale;
        asteroid.userData.boundingRadius *= scale;
        asteroid.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );
        scene.add(asteroid);
        asteroids.push(asteroid);
      }
      function spawnProjectile() {
        if (!playerShip || projectiles.length >= MAX_PROJECTILES) return;
        const projectile = new THREE.Mesh(
          projectileGeometry,
          projectileMaterial
        );
        const spawnOffset = new THREE.Vector3(0, 0, -1);
        spawnOffset.applyQuaternion(playerShip.quaternion);
        projectile.position.copy(playerShip.position).add(spawnOffset);
        const velocity = new THREE.Vector3(0, 0, -PROJECTILE_SPEED);
        projectile.userData = {
          velocity: velocity,
          boundingRadius: PROJECTILE_RADIUS,
          isProjectile: true,
        };
        scene.add(projectile);
        projectiles.push(projectile);
      }

      // --- Update Functions ---
      function updateAsteroids(deltaTime) {
        for (let i = asteroids.length - 1; i >= 0; i--) {
          const asteroid = asteroids[i];
          if (asteroid.userData.isDying) {
            asteroid.userData.dyingTimer -= deltaTime;
            if (asteroid.userData.dyingTimer <= 0) {
              disposeObject(asteroid);
              asteroids.splice(i, 1);
            } else {
              const scaleFactor = THREE.MathUtils.clamp(
                asteroid.userData.dyingTimer / ASTEROID_DESTRUCTION_DURATION,
                0,
                1
              );
              asteroid.scale.setScalar(
                asteroid.userData.originalScale * scaleFactor
              );
            }
            continue;
          }

          if (!asteroid.userData || !asteroid.userData.velocity) {
            console.warn("Asteroid missing user data, removing:", asteroid);
            disposeObject(asteroid);
            asteroids.splice(i, 1);
            continue;
          }
          const velocity = asteroid.userData.velocity;
          const rotSpeed = asteroid.userData.rotationSpeed;
          asteroid.position.addScaledVector(velocity, deltaTime);
          asteroid.rotation.x += rotSpeed.x * deltaTime;
          asteroid.rotation.y += rotSpeed.y * deltaTime;
          asteroid.rotation.z += rotSpeed.z * deltaTime;

          const despawnZ = camera.position.z + DESPAWN_DISTANCE;
          if (asteroid.position.z > despawnZ) {
            disposeObject(asteroid);
            asteroids.splice(i, 1);
          }
        }
      }
      function updateProjectiles(deltaTime) {
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const projectile = projectiles[i];
          if (!projectile.userData || !projectile.userData.velocity) {
            console.warn("Projectile missing user data, removing:", projectile);
            disposeObject(projectile);
            projectiles.splice(i, 1);
            continue;
          }
          const velocity = projectile.userData.velocity;
          projectile.position.addScaledVector(velocity, deltaTime);
          if (projectile.position.z < PROJECTILE_DESPAWN_Z) {
            disposeObject(projectile);
            projectiles.splice(i, 1);
          }
        }
      }
      function updatePlayerShip(deltaTime) {
        if (!playerShip) return;
        playerShip.position.lerp(targetShipPosition, PLAYER_SMOOTHING);
        if (shipBoundingSphere)
          shipBoundingSphere.center.copy(playerShip.position);

        const bankAmount = (targetShipPosition.x - playerShip.position.x) * 0.5;
        const tiltAmount = (targetShipPosition.y - playerShip.position.y) * 0.2;
        const targetQuaternion = new THREE.Quaternion();
        const baseRotationX = Math.PI * 0.05;
        const targetEuler = new THREE.Euler(
          baseRotationX - tiltAmount,
          0,
          -bankAmount,
          "XYZ"
        );
        targetQuaternion.setFromEuler(targetEuler);
        playerShip.quaternion.slerp(targetQuaternion, PLAYER_SMOOTHING * 1.5);

        // Handle invulnerability flashing
        if (isInvulnerable) {
          invulnerabilityTimer -= deltaTime;
          // Flash every ~0.1 seconds
          shipFlashToggle = !shipFlashToggle;
          playerShip.visible = shipFlashToggle; // Toggle visibility for flashing

          if (invulnerabilityTimer <= 0) {
            isInvulnerable = false;
            playerShip.visible = true; // Ensure ship is visible at the end
          }
        } else {
          if (playerShip && !playerShip.visible) {
            playerShip.visible = true; // Ensure visible if not invulnerable
          }
        }
      }

      // --- Collision Detection ---
      function checkShipAsteroidCollision() {
        if (!playerShip || !shipBoundingSphere || isInvulnerable || isGameOver)
          return; // No collision if invulnerable or game over

        for (let i = asteroids.length - 1; i >= 0; i--) {
          // Iterate backwards for safe removal
          const asteroid = asteroids[i];
          if (
            !asteroid.userData ||
            asteroid.userData.isDying ||
            asteroid.userData.boundingRadius === undefined
          )
            continue;

          const asteroidRadius = asteroid.userData.boundingRadius;
          const distance = playerShip.position.distanceTo(asteroid.position);

          if (distance < shipBoundingSphere.radius + asteroidRadius) {
            // Collision detected!
            playerHealth -= SHIP_COLLISION_DAMAGE;
            isInvulnerable = true;
            invulnerabilityTimer = INVULNERABILITY_DURATION;
            shipFlashToggle = false; // Start flashing cycle

            // Destroy the asteroid that hit the player
            markAsteroidAsDying(asteroid); // This also increments counter and updates UI

            updateUI(); // Update health bar immediately

            console.log("Ship hit! Health:", playerHealth);

            if (playerHealth <= 0) {
              gameOver();
            }
            // Only process one collision per frame
            break;
          }
        }
      }

      function checkProjectileAsteroidCollisions() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const projectile = projectiles[i];
          if (!projectile.userData || !projectile.userData.velocity) continue;

          for (let j = asteroids.length - 1; j >= 0; j--) {
            const asteroid = asteroids[j];
            if (
              !asteroid.userData ||
              asteroid.userData.isDying ||
              !asteroid.userData.velocity
            )
              continue;

            const distance = projectile.position.distanceTo(asteroid.position);
            const collisionThreshold =
              projectile.userData.boundingRadius +
              asteroid.userData.boundingRadius;

            if (distance < collisionThreshold) {
              markAsteroidAsDying(asteroid); // Marks as dying, starts flash/shrink, increments counter, updates UI

              disposeObject(projectile);
              projectiles.splice(i, 1);
              break; // Projectile hit one asteroid, move to next projectile
            }
          }
        }
      }

      // --- Game Flow ---
      function gameOver() {
        console.log("Game Over! Final Score:", asteroidsDestroyed);
        isGameOver = true;
        isShooting = false;
        cancelAnimationFrame(animationFrameId);

        finalScoreDisplay.textContent = `Final Score: ${asteroidsDestroyed}`; // Update final score display
        gameOverScreen.style.display = "flex";
        document.body.style.cursor = "default";
        if (playerShip) playerShip.visible = true;

        // Attempt to save score and display leaderboard
        saveHighScore(asteroidsDestroyed); // Save score (async, non-blocking)
        fetchAndDisplayHighScores(); // Fetch and display scores (async, non-blocking)
      }

      function restartGame() {
        isGameOver = false;
        isShooting = false;
        gameOverScreen.style.display = "none";
        document.body.style.cursor = "none";

        targetShipPosition.set(0, -1, SHIP_DEPTH);
        if (playerShip) {
          playerShip.position.copy(targetShipPosition);
          playerShip.quaternion.set(0, 0, 0, 1);
          playerShip.rotation.x = Math.PI * 0.05;
          playerShip.visible = true;
        }

        // Clear existing objects
        asteroids.forEach(disposeObject);
        asteroids.length = 0;
        projectiles.forEach(disposeObject);
        projectiles.length = 0;

        // Reset game state
        timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE;
        timeSinceLastShot = 0;
        playerHealth = SHIP_INITIAL_HEALTH;
        asteroidsDestroyed = 0;
        totalAsteroidsSpawned = 0;
        isInvulnerable = false;
        invulnerabilityTimer = 0;
        asteroidSpeed = INITIAL_ASTEROID_SPEED; // Reset speed

        updateUI();
        startGame();
      }

      function startGame() {
        isGameOver = false;
        isShooting = false;
        document.body.style.cursor = "none";
        updateUI();
        animate();
      }

      function animate() {
        if (isGameOver) return;
        animationFrameId = requestAnimationFrame(animate);

        const deltaTime = clock.getDelta();
        timeSinceLastShot += deltaTime;

        // Spawning
        timeToNextSpawn -= deltaTime;
        if (timeToNextSpawn <= 0) {
          spawnAsteroid();
          timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE;
        }
        if (isShooting && timeSinceLastShot >= SHOT_COOLDOWN) {
          spawnProjectile();
          timeSinceLastShot = 0;
        }

        // Updates
        updateAsteroids(deltaTime);
        updateProjectiles(deltaTime);
        updatePlayerShip(deltaTime);

        // Collisions
        checkProjectileAsteroidCollisions();
        checkShipAsteroidCollision();

        renderer.render(scene, camera);
      }

      // --- Event Listeners & Initial Check ---
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      if (!renderer.getContext()) {
        instructionsDiv.innerText = "WebGL is not supported by your browser!";
        instructionsDiv.style.color = "red";
        instructionsDiv.style.display = "block";
        gameOverScreen.style.display = "none";
        document.getElementById("hud").style.display = "none";
        document.getElementById("asteroidCounter").style.display = "none";
        speedIndicatorDisplay.style.display = "none";
      }
    </script>
  </body>
</html>
