<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Asteroid Shooter</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        /* cursor: none; /* Manage cursor visibility in JS */
      }
      canvas {
        display: block;
      }
      #instructions {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: sans-serif;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px;
        border-radius: 3px;
        display: none;
        z-index: 10;
      }
      #gameOverScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        font-family: sans-serif;
        display: none; /* Initially hidden */
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 20;
        cursor: default; /* Show default cursor over the overlay */
      }
      #gameOverScreen h1 {
        margin-bottom: 20px;
      }
      #restartButton {
        padding: 10px 20px;
        font-size: 1.2em;
        cursor: pointer; /* Pointer specifically for the button */
        border: none;
        border-radius: 5px;
        background-color: #eee;
        color: #333;
      }
      #restartButton:hover {
        background-color: #ddd;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <div id="instructions">Loading assets...</div>
    <div id="gameOverScreen">
      <h1>Game Over</h1>
      <button id="restartButton">Restart Game</button>
    </div>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.156.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.156.1/examples/jsm/",
          "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
      import { createNoise3D } from "simplex-noise";

      const ASTEROID_SPAWN_RATE = 3;
      const ASTEROID_SPEED = 15.0;
      const ASTEROID_SCALE_MIN = 0.4;
      const ASTEROID_SCALE_MAX = 1.2;
      const ASTEROID_BASE_RADIUS = 1.0;
      const SPAWN_AREA_WIDTH_RATIO = 0.4;

      const PLAYER_SMOOTHING = 0.08;
      const SHIP_DEPTH = 0;
      const SPAWN_DISTANCE = 20;
      const DESPAWN_DISTANCE = 0;
      const MAX_ASTEROIDS = 50;
      const MOVEMENT_RATIO = 2.0;
      const SHIP_COLLISION_RADIUS_FACTOR = 0.4;

      const PROJECTILE_SPEED = 100.0;
      const PROJECTILE_RADIUS = 0.1;
      const SHOT_COOLDOWN = 0.15;
      const MAX_PROJECTILES = 30;
      const PROJECTILE_DESPAWN_Z = -30;

      const ASTEROID_DESTRUCTION_DURATION = 0.2; // Duration for shrink animation
      const ASTEROID_FLASH_COLOR = new THREE.Color(0xffffff); // White flash

      const renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById("c"),
        antialias: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 5;

      scene.add(new THREE.AmbientLight(0xffffff, 1));
      const dirLight = new THREE.DirectionalLight(0xffffff, 20.8);
      dirLight.position.set(5, 8, 7);
      scene.add(dirLight);

      const clock = new THREE.Clock();

      let playerShip = null;
      const asteroids = [];
      const projectiles = [];
      let targetShipPosition = new THREE.Vector3(0, -1, SHIP_DEPTH);
      const mouseNDC = new THREE.Vector2();

      let isTouching = false;
      let isShooting = false;
      let touchStartPos = new THREE.Vector2();
      let touchStartShipPos = new THREE.Vector3();
      let timeSinceLastShot = 0;

      const loadingManager = new THREE.LoadingManager();
      const fbxLoader = new FBXLoader(loadingManager);
      const textureLoader = new THREE.TextureLoader(loadingManager);
      const instructionsDiv = document.getElementById("instructions");
      const gameOverScreen = document.getElementById("gameOverScreen");
      const restartButton = document.getElementById("restartButton");
      instructionsDiv.style.display = "block";

      let isGameOver = false;
      let animationFrameId = null;
      let shipBoundingSphere = null;

      document.body.style.cursor = "none";

      const backgroundTexture = textureLoader.load(
        "./assets/background.png",
        (texture) => {
          scene.background = texture;
        },
        (xhr) => {},
        (error) => {
          console.error("Error loading background texture:", error);
          instructionsDiv.innerText = `Error loading background: assets/background.png. Check path/file.`;
          instructionsDiv.style.color = "red";
          instructionsDiv.style.display = "block";
        }
      );

      const shipModelPath = "./assets/Galactic_Soarer_0504175114_texture.fbx";

      fbxLoader.load(
        shipModelPath,
        (fbx) => {
          playerShip = fbx;
          playerShip.scale.setScalar(0.02);
          playerShip.rotation.x = Math.PI * 0.05;
          playerShip.position.set(
            targetShipPosition.x,
            targetShipPosition.y,
            SHIP_DEPTH
          );
          scene.add(playerShip);

          const box = new THREE.Box3().setFromObject(playerShip, true);
          shipBoundingSphere = new THREE.Sphere();
          box.getBoundingSphere(shipBoundingSphere);
          shipBoundingSphere.radius *= SHIP_COLLISION_RADIUS_FACTOR;
        },
        (xhr) => {
          const percentLoaded = (xhr.loaded / xhr.total) * 100;
          if (!scene.background) {
            instructionsDiv.innerText = `Loading ship: ${Math.round(
              percentLoaded
            )}%`;
          }
        },
        (error) => {
          console.error("Error loading FBX model:", error);
          instructionsDiv.innerText = `Error loading ship: ${shipModelPath}. Check path and console.`;
          instructionsDiv.style.color = "red";
          instructionsDiv.style.display = "block";
        }
      );

      const projectileGeometry = new THREE.SphereGeometry(
        PROJECTILE_RADIUS,
        8,
        8
      );
      const projectileMaterial = new THREE.MeshBasicMaterial({
        color: 0xffff00, // Yellow projectiles
      });

      loadingManager.onLoad = () => {
        if (!instructionsDiv.innerText.startsWith("Error")) {
          instructionsDiv.style.display = "none";
        }
        setupInputListeners();
        restartButton.addEventListener("click", restartGame);
        startGame();
      };

      loadingManager.onError = (url) => {
        console.error("There was an error loading " + url);
      };

      function makeAsteroid() {
        const RADIUS = ASTEROID_BASE_RADIUS;
        const SEGMENTS = 8;
        const geometry = new THREE.SphereGeometry(RADIUS, SEGMENTS, SEGMENTS);

        const noise3D = createNoise3D();
        const posAttr = geometry.attributes.position;
        const v = new THREE.Vector3();

        const OCTAVES = 3;
        const BASE_FREQ = 1.4;
        const BASE_AMP = 0.18;

        for (let i = 0; i < posAttr.count; i++) {
          v.fromBufferAttribute(posAttr, i).normalize();
          let n = 0,
            amp = 1,
            freq = BASE_FREQ;
          for (let o = 0; o < OCTAVES; o++) {
            n += amp * noise3D(v.x * freq, v.y * freq, v.z * freq);
            amp *= 0.5;
            freq *= 2.0;
          }
          v.multiplyScalar(RADIUS + n * BASE_AMP);
          posAttr.setXYZ(i, v.x, v.y, v.z);
        }

        posAttr.needsUpdate = true;
        geometry.computeVertexNormals();
        geometry.computeBoundingSphere();

        const mainMaterial = new THREE.MeshToonMaterial({
          color: 0xdd44aa,
          emissive: 0x110011,
          flatShading: true,
        });
        const mainAsteroid = new THREE.Mesh(geometry, mainMaterial);
        mainAsteroid.userData.originalColor = mainMaterial.color.clone(); // Store original color

        const outlineMaterial = new THREE.MeshBasicMaterial({
          color: 0x220022,
          side: THREE.BackSide,
        });
        const outlineMesh = new THREE.Mesh(geometry.clone(), outlineMaterial);
        const OUTLINE_SCALE = 1.06;
        outlineMesh.scale.set(OUTLINE_SCALE, OUTLINE_SCALE, OUTLINE_SCALE);
        mainAsteroid.add(outlineMesh);
        outlineMesh.userData.originalColor = outlineMaterial.color.clone(); // Store original outline color

        const speed = ASTEROID_SPEED;

        const dirX = 0;
        const dirY = 0;
        const dirZ = 1.0;

        const velocity = new THREE.Vector3(dirX, dirY, dirZ)
          .normalize()
          .multiplyScalar(speed);

        mainAsteroid.userData = {
          ...mainAsteroid.userData, // Keep originalColor stored above
          velocity: velocity,
          rotationSpeed: new THREE.Vector3(
            THREE.MathUtils.randFloat(-0.5, 0.5),
            THREE.MathUtils.randFloat(-0.5, 0.5),
            THREE.MathUtils.randFloat(-0.5, 0.5)
          ),
          boundingRadius: geometry.boundingSphere.radius, // Store original geometry radius
          isAsteroid: true,
          isDying: false, // Add dying flag
          dyingTimer: 0,
          originalScale: 1.0, // Will be set when spawned
        };

        return mainAsteroid;
      }

      function setupInputListeners() {
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("mousedown", onMouseDown);
        window.addEventListener("mouseup", onMouseUp);
        window.addEventListener("touchstart", onTouchStart, { passive: false });
        window.addEventListener("touchmove", onTouchMove, { passive: false });
        window.addEventListener("touchend", onTouchEnd);
        window.addEventListener("touchcancel", onTouchEnd);
      }

      function screenToWorld(clientX, clientY) {
        const screenNDC = new THREE.Vector2();
        screenNDC.x = (clientX / window.innerWidth) * 2 - 1;
        screenNDC.y = -(clientY / window.innerHeight) * 2 + 1;

        const vector = new THREE.Vector3(screenNDC.x, screenNDC.y, 0.5);
        vector.unproject(camera);

        const dir = vector.sub(camera.position).normalize();
        const distance = (SHIP_DEPTH - camera.position.z) / dir.z;
        const worldPos = new THREE.Vector3();
        worldPos.copy(camera.position).add(dir.multiplyScalar(distance));
        return worldPos;
      }

      function clampTargetShipPosition() {
        const visibleHeight =
          2 *
          Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) *
          Math.abs(SHIP_DEPTH - camera.position.z);
        const visibleWidth = visibleHeight * camera.aspect;

        targetShipPosition.x = THREE.MathUtils.clamp(
          targetShipPosition.x,
          -visibleWidth / 2.2,
          visibleWidth / 2.2
        );
        targetShipPosition.y = THREE.MathUtils.clamp(
          targetShipPosition.y,
          -visibleHeight / 2.2,
          visibleHeight / 2.2
        );
        targetShipPosition.z = SHIP_DEPTH;
      }

      function updateTargetPositionFromScreenCoords(clientX, clientY) {
        mouseNDC.x = (clientX / window.innerWidth) * 2 - 1;
        mouseNDC.y = -(clientY / window.innerHeight) * 2 + 1;

        const vector = new THREE.Vector3(mouseNDC.x, mouseNDC.y, 0.5);
        vector.unproject(camera);

        const dir = vector.sub(camera.position).normalize();
        const distance = (SHIP_DEPTH - camera.position.z) / dir.z;

        targetShipPosition
          .copy(camera.position)
          .add(dir.multiplyScalar(distance));

        clampTargetShipPosition();
      }

      function onMouseMove(event) {
        if (isGameOver) return;
        updateTargetPositionFromScreenCoords(event.clientX, event.clientY);
      }

      function onMouseDown(event) {
        if (isGameOver) return;
        if (event.button === 0) {
          isShooting = true;
        }
      }

      function onMouseUp(event) {
        if (event.button === 0) {
          isShooting = false;
        }
      }

      function onTouchStart(event) {
        if (isGameOver) return;
        event.preventDefault();
        isShooting = true;
        if (event.touches.length === 1 && !isTouching) {
          isTouching = true;
          const touch = event.touches[0];
          touchStartPos.set(touch.clientX, touch.clientY);
          if (playerShip) {
            touchStartShipPos.copy(playerShip.position);
          } else {
            touchStartShipPos.copy(targetShipPosition);
          }
        }
      }

      function onTouchMove(event) {
        if (isGameOver) return;
        event.preventDefault();
        if (isTouching && event.touches.length > 0) {
          const touch = event.touches[0];
          const currentTouchPos = new THREE.Vector2(
            touch.clientX,
            touch.clientY
          );
          const worldStartPos = screenToWorld(touchStartPos.x, touchStartPos.y);
          const worldCurrentPos = screenToWorld(
            currentTouchPos.x,
            currentTouchPos.y
          );
          const worldDelta = worldCurrentPos.sub(worldStartPos);
          targetShipPosition
            .copy(touchStartShipPos)
            .addScaledVector(worldDelta, MOVEMENT_RATIO);
          clampTargetShipPosition();
        }
      }

      function onTouchEnd(event) {
        if (event.touches.length === 0) {
          isShooting = false;
          isTouching = false;
        } else {
          let movementTouchStillActive = false;
          for (let i = 0; i < event.touches.length; i++) {
            movementTouchStillActive = true;
            break;
          }
          if (!movementTouchStillActive) {
            isTouching = false;
          }
          isShooting = true;
        }
      }

      function spawnAsteroid() {
        if (asteroids.length >= MAX_ASTEROIDS) return;

        const asteroid = makeAsteroid();

        const spawnZ = camera.position.z - SPAWN_DISTANCE;

        const height =
          2 *
          Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) *
          Math.abs(spawnZ - camera.position.z);
        const width = height * camera.aspect;
        
        asteroid.position.set(
            THREE.MathUtils.randFloatSpread(width * SPAWN_AREA_WIDTH_RATIO),
          THREE.MathUtils.randFloatSpread(height * SPAWN_AREA_WIDTH_RATIO),
          spawnZ
        );

        const scale = THREE.MathUtils.randFloat(
          ASTEROID_SCALE_MIN,
          ASTEROID_SCALE_MAX
        );
        asteroid.scale.setScalar(scale);
        asteroid.userData.originalScale = scale; // Store the actual initial scale
        // Scale the bounding radius based on geometry radius and final scale
        asteroid.userData.boundingRadius *= scale;

        asteroid.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );

        scene.add(asteroid);
        asteroids.push(asteroid);
      }

      function spawnProjectile() {
        if (!playerShip || projectiles.length >= MAX_PROJECTILES) return;

        const projectile = new THREE.Mesh(
          projectileGeometry,
          projectileMaterial
        );

        const spawnOffset = new THREE.Vector3(0, 0, -1);
        spawnOffset.applyQuaternion(playerShip.quaternion);
        projectile.position.copy(playerShip.position).add(spawnOffset);

        const velocity = new THREE.Vector3(0, 0, -PROJECTILE_SPEED);

        projectile.userData = {
          velocity: velocity,
          boundingRadius: PROJECTILE_RADIUS,
          isProjectile: true,
        };

        scene.add(projectile);
        projectiles.push(projectile);
      }

      function updateAsteroids(deltaTime) {
        for (let i = asteroids.length - 1; i >= 0; i--) {
          const asteroid = asteroids[i];

          // --- Handle Dying Asteroids ---
          if (asteroid.userData.isDying) {
            asteroid.userData.dyingTimer -= deltaTime;

            if (asteroid.userData.dyingTimer <= 0) {
              disposeObject(asteroid);
              asteroids.splice(i, 1);
            } else {
              // Calculate scale based on remaining time
              const scaleFactor = THREE.MathUtils.clamp(
                asteroid.userData.dyingTimer / ASTEROID_DESTRUCTION_DURATION,
                0,
                1 // Clamp between 0 and 1
              );
              asteroid.scale.setScalar(
                asteroid.userData.originalScale * scaleFactor
              );
              // Optional: Could also fade color back from white here if desired
            }
            continue; // Skip normal updates for dying asteroids
          }
          // --- End Dying Asteroid Handling ---

          // Normal asteroid update
          if (!asteroid.userData || !asteroid.userData.velocity) {
            console.warn("Asteroid missing user data, removing:", asteroid);
            disposeObject(asteroid); // Use disposeObject here too
            asteroids.splice(i, 1);
            continue;
          }
          const velocity = asteroid.userData.velocity;
          const rotSpeed = asteroid.userData.rotationSpeed;

          asteroid.position.addScaledVector(velocity, deltaTime);

          asteroid.rotation.x += rotSpeed.x * deltaTime;
          asteroid.rotation.y += rotSpeed.y * deltaTime;
          asteroid.rotation.z += rotSpeed.z * deltaTime;

          const despawnZ = camera.position.z + DESPAWN_DISTANCE;
          if (asteroid.position.z > despawnZ) {
            disposeObject(asteroid);
            asteroids.splice(i, 1);
          }
        }
      }

      function updateProjectiles(deltaTime) {
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const projectile = projectiles[i];
          if (!projectile.userData || !projectile.userData.velocity) {
            console.warn("Projectile missing user data, removing:", projectile);
            disposeObject(projectile); // Use disposeObject
            projectiles.splice(i, 1);
            continue;
          }
          const velocity = projectile.userData.velocity;

          projectile.position.addScaledVector(velocity, deltaTime);

          if (projectile.position.z < PROJECTILE_DESPAWN_Z) {
            disposeObject(projectile);
            projectiles.splice(i, 1);
          }
        }
      }

      function updatePlayerShip(deltaTime) {
        if (!playerShip) return;

        playerShip.position.lerp(targetShipPosition, PLAYER_SMOOTHING);

        if (shipBoundingSphere) {
          shipBoundingSphere.center.copy(playerShip.position);
        }

        const bankAmount = (targetShipPosition.x - playerShip.position.x) * 0.5;
        const tiltAmount = (targetShipPosition.y - playerShip.position.y) * 0.2;

        const targetQuaternion = new THREE.Quaternion();
        const baseRotationX = Math.PI * 0.05;

        const targetEuler = new THREE.Euler(
          baseRotationX - tiltAmount,
          0,
          -bankAmount,
          "XYZ"
        );
        targetQuaternion.setFromEuler(targetEuler);

        playerShip.quaternion.slerp(targetQuaternion, PLAYER_SMOOTHING * 1.5);
      }

      function checkShipAsteroidCollision() {
        if (!playerShip || !shipBoundingSphere) return false;

        for (let i = 0; i < asteroids.length; i++) {
          const asteroid = asteroids[i];
          // Skip collision check if asteroid is already dying
          if (
            !asteroid.userData ||
            asteroid.userData.isDying ||
            asteroid.userData.boundingRadius === undefined
          )
            continue;

          const asteroidRadius = asteroid.userData.boundingRadius;
          const distance = playerShip.position.distanceTo(asteroid.position);

          if (distance < shipBoundingSphere.radius + asteroidRadius) {
            return true;
          }
        }
        return false;
      }

      function checkProjectileAsteroidCollisions() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const projectile = projectiles[i];
          if (!projectile.userData || !projectile.userData.velocity) continue;

          for (let j = asteroids.length - 1; j >= 0; j--) {
            const asteroid = asteroids[j];
            // Skip collision check if asteroid is already dying
            if (
              !asteroid.userData ||
              asteroid.userData.isDying ||
              !asteroid.userData.velocity
            )
              continue;

            const distance = projectile.position.distanceTo(asteroid.position);
            const collisionThreshold =
              projectile.userData.boundingRadius +
              asteroid.userData.boundingRadius;

            if (distance < collisionThreshold) {
              // --- Start Asteroid Destruction Animation ---
              asteroid.userData.isDying = true;
              asteroid.userData.dyingTimer = ASTEROID_DESTRUCTION_DURATION;
              // Store original scale *if not already stored* (should be set at spawn)
              // asteroid.userData.originalScale = asteroid.scale.x;

              // Flash Effect
              asteroid.material.color.copy(ASTEROID_FLASH_COLOR);
              asteroid.material.emissive.copy(ASTEROID_FLASH_COLOR); // Make it glow white
              // Flash outline too (optional)
              if (asteroid.children[0] && asteroid.children[0].material) {
                asteroid.children[0].material.color.copy(ASTEROID_FLASH_COLOR);
              }

              // Stop movement (handled now in updateAsteroids)
              // asteroid.userData.velocity.set(0,0,0);
              // asteroid.userData.rotationSpeed.set(0,0,0);
              // --- End Asteroid Destruction Animation ---

              // Remove the projectile immediately
              disposeObject(projectile);
              projectiles.splice(i, 1);

              break; // Projectile is destroyed, move to the next projectile
            }
          }
        }
      }

      function disposeObject(obj) {
        if (!obj) return;

        // Remove from scene first
        if (obj.parent) {
          obj.parent.remove(obj);
        } else if (scene.children.includes(obj)) {
          // Check if it's a direct child of the scene
          scene.remove(obj);
        }

        // Dispose geometry and material(s)
        if (obj.geometry) {
          obj.geometry.dispose();
        }
        if (obj.material) {
          if (Array.isArray(obj.material)) {
            obj.material.forEach((material) => {
              if (material.map) material.map.dispose(); // Dispose textures
              material.dispose();
            });
          } else {
            if (obj.material.map) obj.material.map.dispose(); // Dispose texture
            obj.material.dispose();
          }
        }

        // Dispose children recursively
        // Use a while loop as modifying the array while iterating can cause issues
        while (obj.children.length > 0) {
          disposeObject(obj.children[0]); // Recursively dispose the first child
          // The child should have been removed from its parent in the recursive call,
          // but double-check or ensure obj.remove(obj.children[0]) happens if needed.
        }
      }

      function gameOver() {
        isGameOver = true;
        isShooting = false;
        cancelAnimationFrame(animationFrameId);
        gameOverScreen.style.display = "flex";
        document.body.style.cursor = "default";
      }

      function restartGame() {
        isGameOver = false;
        isShooting = false;
        gameOverScreen.style.display = "none";
        document.body.style.cursor = "none";

        targetShipPosition.set(0, -1, SHIP_DEPTH);
        if (playerShip) {
          playerShip.position.copy(targetShipPosition);
          playerShip.quaternion.set(0, 0, 0, 1);
          playerShip.rotation.x = Math.PI * 0.05;
        }

        // Clear existing objects using the dispose helper
        for (let i = asteroids.length - 1; i >= 0; i--) {
          disposeObject(asteroids[i]);
        }
        asteroids.length = 0;

        for (let i = projectiles.length - 1; i >= 0; i--) {
          disposeObject(projectiles[i]);
        }
        projectiles.length = 0;

        timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE;
        timeSinceLastShot = 0;

        // Clock delta reset is handled automatically by getDelta()
        startGame();
      }

      function startGame() {
        isGameOver = false;
        isShooting = false;
        document.body.style.cursor = "none";
        animate();
      }

      let timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE;

      function animate() {
        if (isGameOver) return;

        animationFrameId = requestAnimationFrame(animate);

        const deltaTime = clock.getDelta();
        timeSinceLastShot += deltaTime;

        timeToNextSpawn -= deltaTime;
        if (timeToNextSpawn <= 0) {
          spawnAsteroid();
          timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE;
        }

        if (isShooting && timeSinceLastShot >= SHOT_COOLDOWN) {
          spawnProjectile();
          timeSinceLastShot = 0;
        }

        // Update order is important: update asteroids *including* dying animation first
        updateAsteroids(deltaTime);
        updateProjectiles(deltaTime);
        updatePlayerShip(deltaTime);

        // Collisions checked after updates
        checkProjectileAsteroidCollisions();

        if (checkShipAsteroidCollision()) {
          gameOver();
          return;
        }

        renderer.render(scene, camera);
      }

      window.addEventListener("resize", () => {
        // Allow resize even if game over, doesn't hurt
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      if (!renderer.getContext()) {
        instructionsDiv.innerText = "WebGL is not supported by your browser!";
        instructionsDiv.style.color = "red";
        instructionsDiv.style.display = "block";
        gameOverScreen.style.display = "none";
      }
    </script>
  </body>
</html>
