<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Asteroid Dodger</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; cursor: none; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: sans-serif;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="instructions">Move mouse/touch to control the ship</div>
    <canvas id="c"></canvas>

    <!-- ES-module Shims for older browser compatibility (optional but good practice) -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.156.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.156.1/examples/jsm/",
             "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
        }
    }
    </script>

    <script type="module">
        /* ---------- IMPORTS ---------- */
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { createNoise3D } from 'simplex-noise';

        /* ---------- GAME CONSTANTS ---------- */
        const ASTEROID_SPAWN_RATE = 0.8; // Asteroids per second
        const ASTEROID_SPEED_MIN = 2.5;
        const ASTEROID_SPEED_MAX = 5.0;
        const ASTEROID_SCALE_MIN = 0.4;
        const ASTEROID_SCALE_MAX = 1.2;
        const PLAYER_SMOOTHING = 0.08; // Lower values = smoother/slower follow
        const SHIP_DEPTH = -2; // How far the ship is in front of the camera origin
        const SPAWN_DISTANCE = 30; // How far away asteroids spawn
        const DESPAWN_DISTANCE = -10; // How far behind the camera asteroids get removed
        const MAX_ASTEROIDS = 50;
        const STAR_COUNT = 5000;

        /* ---------- CORE THREE.JS SETUP ---------- */
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('c'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5; // Move camera back slightly

        // --- Lighting ---
        scene.add(new THREE.AmbientLight(0x606060));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 8, 7);
        scene.add(dirLight);

        const clock = new THREE.Clock();

        /* ---------- GAME OBJECTS & STATE ---------- */
        let playerShip = null;
        const asteroids = [];
        let targetShipPosition = new THREE.Vector3(0, -2, SHIP_DEPTH); // Initial target below center
        const mouseNDC = new THREE.Vector2(); // Normalized Device Coordinates (-1 to +1)

        /* ---------- ASSET LOADING ---------- */
        const loadingManager = new THREE.LoadingManager();
        const fbxLoader = new FBXLoader(loadingManager);

        // --- Load Spaceship ---
        // *** MAKE SURE you unzipped the file and the FBX is here ***
        const shipModelPath = './assets/Galactic_Soarer_0504175114_texture.fbx'; // Adjust if filename differs after unzipping

        fbxLoader.load(
            shipModelPath,
            (fbx) => {
                playerShip = fbx;
                playerShip.scale.setScalar(0.008); // Scale might need adjustment
                playerShip.rotation.x = Math.PI * 0.05; // Slight tilt up
                playerShip.position.set(0, -2, SHIP_DEPTH); // Initial position
                scene.add(playerShip);
                console.log('Ship loaded!');
            },
            (xhr) => {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            (error) => {
                console.error('Error loading FBX model:', error);
                // Provide fallback or error message
                 document.getElementById('instructions').innerText = `Error loading ship: ${shipModelPath}. Make sure it's unzipped and in the same folder.`;
                 document.getElementById('instructions').style.color = 'red';
            }
        );

        loadingManager.onLoad = () => {
            console.log("All assets loaded");
            setupInputListeners();
            animate();
        }

        /* ---------- ASTEROID GENERATION (from original code, slightly modified) ---------- */
        function makeAsteroid() {
            const RADIUS = 1;
            const SEGMENTS = 8; // Slightly more detail
            const geometry = new THREE.SphereGeometry(RADIUS, SEGMENTS, SEGMENTS);

            const noise3D = createNoise3D();
            const posAttr = geometry.attributes.position;
            const v = new THREE.Vector3();

            const OCTAVES = 3;
            const BASE_FREQ = 1.4;
            const BASE_AMP = 0.18; // Slightly more bumpy

            for (let i = 0; i < posAttr.count; i++) {
                v.fromBufferAttribute(posAttr, i).normalize();
                let n = 0, amp = 1, freq = BASE_FREQ;
                for (let o = 0; o < OCTAVES; o++) {
                    n += amp * noise3D(v.x * freq, v.y * freq, v.z * freq);
                    amp *= 0.5;
                    freq *= 2.0;
                }
                v.multiplyScalar(RADIUS + n * BASE_AMP);
                posAttr.setXYZ(i, v.x, v.y, v.z);
            }

            posAttr.needsUpdate = true;
            geometry.computeVertexNormals();

            const mainMaterial = new THREE.MeshToonMaterial({
                color: 0xDD44AA, // Pink color from screenshot
                 // emissive: 0x110011, // Optional slight glow
                flatShading: true
            });
            const mainAsteroid = new THREE.Mesh(geometry, mainMaterial);

            // --- Outline (optional, but nice) ---
            const outlineMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.BackSide
            });
            const outlineMesh = new THREE.Mesh(geometry.clone(), outlineMaterial); // Use CLONE for outline
            const OUTLINE_SCALE = 1.06;
            outlineMesh.scale.set(OUTLINE_SCALE, OUTLINE_SCALE, OUTLINE_SCALE);
            mainAsteroid.add(outlineMesh); // Add outline as child

            // --- Game Data ---
            const speed = THREE.MathUtils.randFloat(ASTEROID_SPEED_MIN, ASTEROID_SPEED_MAX);
             // Aim slightly towards the player's general area but with randomness
            const targetX = THREE.MathUtils.randFloat(-2, 2);
            const targetY = THREE.MathUtils.randFloat(-2, 2);
            const velocity = new THREE.Vector3(targetX, targetY, -speed).normalize().multiplyScalar(speed);

            mainAsteroid.userData = {
                velocity: velocity,
                rotationSpeed: new THREE.Vector3(
                    THREE.MathUtils.randFloat(-0.5, 0.5),
                    THREE.MathUtils.randFloat(-0.5, 0.5),
                    THREE.MathUtils.randFloat(-0.5, 0.5)
                )
            };

            return mainAsteroid;
        }


        /* ---------- INPUT HANDLING ---------- */
        function setupInputListeners() {
             window.addEventListener('mousemove', onPointerMove);
             window.addEventListener('touchmove', onPointerMove, { passive: false }); // Use passive: false if preventDefault is needed
             window.addEventListener('touchstart', onPointerMove, { passive: false });
        }

        function onPointerMove(event) {
             // Prevent scrolling on touch devices
             if (event.type.startsWith('touch')) {
                 event.preventDefault();
             }

            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            // Convert mouse/touch position to Normalized Device Coordinates (-1 to +1)
            mouseNDC.x = (clientX / window.innerWidth) * 2 - 1;
            mouseNDC.y = -(clientY / window.innerHeight) * 2 + 1;

            // Project NDC to world space at the ship's depth
            const vector = new THREE.Vector3(mouseNDC.x, mouseNDC.y, 0.5); // z=0.5 is between near/far planes
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = (SHIP_DEPTH - camera.position.z) / dir.z;
            targetShipPosition.copy(camera.position).add(dir.multiplyScalar(distance));

            // Optional: Clamp ship movement to screen edges (adjust bounds as needed)
            const visibleHeight = 2 * Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) * Math.abs(SHIP_DEPTH - camera.position.z);
            const visibleWidth = visibleHeight * camera.aspect;
            targetShipPosition.x = THREE.MathUtils.clamp(targetShipPosition.x, -visibleWidth / 2.2, visibleWidth / 2.2);
            targetShipPosition.y = THREE.MathUtils.clamp(targetShipPosition.y, -visibleHeight / 2.2, visibleHeight / 2.2);

        }


        /* ---------- GAME LOGIC ---------- */
        function spawnAsteroid() {
            if (asteroids.length >= MAX_ASTEROIDS) return;

            const asteroid = makeAsteroid();

            // Calculate spawn position based on view frustum at SPAWN_DISTANCE
             const height = 2 * Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) * SPAWN_DISTANCE;
             const width = height * camera.aspect;

            asteroid.position.set(
                THREE.MathUtils.randFloatSpread(width * 1.2),   // Spawn slightly outside view horizontally
                THREE.MathUtils.randFloatSpread(height * 1.2), // Spawn slightly outside view vertically
                camera.position.z - SPAWN_DISTANCE // Spawn distance in front of camera (further negative Z)
            );

            const scale = THREE.MathUtils.randFloat(ASTEROID_SCALE_MIN, ASTEROID_SCALE_MAX);
            asteroid.scale.setScalar(scale);

            asteroid.rotation.set(
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2
            );

            scene.add(asteroid);
            asteroids.push(asteroid);
        }

        function updateAsteroids(deltaTime) {
            for (let i = asteroids.length - 1; i >= 0; i--) {
                const asteroid = asteroids[i];
                const velocity = asteroid.userData.velocity;
                const rotSpeed = asteroid.userData.rotationSpeed;

                // Move
                asteroid.position.x += velocity.x * deltaTime;
                asteroid.position.y += velocity.y * deltaTime;
                asteroid.position.z += velocity.z * deltaTime;

                // Rotate
                asteroid.rotation.x += rotSpeed.x * deltaTime;
                asteroid.rotation.y += rotSpeed.y * deltaTime;
                asteroid.rotation.z += rotSpeed.z * deltaTime;

                // Despawn if behind camera
                if (asteroid.position.z > camera.position.z - DESPAWN_DISTANCE) {
                     scene.remove(asteroid);
                     // Make sure to remove outline if it wasn't a child (it is here, so this is safe)
                    // if (asteroid.children.length > 0) scene.remove(asteroid.children[0]);
                    asteroids.splice(i, 1);
                }
            }
        }

        function updatePlayerShip(deltaTime) {
            if (!playerShip) return; // Don't update if not loaded yet

            // Smoothly move ship towards the target position
            playerShip.position.lerp(targetShipPosition, PLAYER_SMOOTHING);

            // Optional: Bank ship slightly based on horizontal movement
            const bankAmount = (targetShipPosition.x - playerShip.position.x) * 0.5;
             const tiltAmount = (targetShipPosition.y - playerShip.position.y) * 0.2;
             // Smooth rotation lerping looks better
             const targetQuaternion = new THREE.Quaternion();
             // Base rotation + bank + tilt
             const baseRotationX = Math.PI * 0.05; // Keep the slight up-tilt
             targetQuaternion.setFromEuler(new THREE.Euler(baseRotationX - tiltAmount, 0, -bankAmount, 'XYZ'));
             playerShip.quaternion.slerp(targetQuaternion, PLAYER_SMOOTHING * 2); // Rotate slightly faster than position

            // playerShip.rotation.z = -bankAmount;
            // playerShip.rotation.x = baseRotationX - tiltAmount;

        }

        /* ---------- RENDER LOOP ---------- */
        let timeToNextSpawn = 0;

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            // --- Spawn new asteroids ---
            timeToNextSpawn -= deltaTime;
            if (timeToNextSpawn <= 0) {
                spawnAsteroid();
                timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE; // Reset timer
            }

            // --- Update game objects ---
            updateAsteroids(deltaTime);
            updatePlayerShip(deltaTime); // Update player ship movement

            // --- Render scene ---
            renderer.render(scene, camera);
        }

        /* ---------- HANDLE RESIZES ---------- */
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initial setup check
        if (!window.WebGLRenderingContext) {
             document.getElementById('instructions').innerText = 'WebGL is not supported by your browser!';
             document.getElementById('instructions').style.color = 'red';
        }

    </script>
</body>
</html>