<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Asteroid Dodger</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        cursor: none;
      }
      canvas {
        display: block;
      }
      #instructions {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: sans-serif;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px;
        border-radius: 3px;
        display: none;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <div id="instructions">Loading assets...</div>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.156.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.156.1/examples/jsm/",
          "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
      import { createNoise3D } from "simplex-noise";

      const ASTEROID_SPAWN_RATE = 3;
      const ASTEROID_SPEED = 5.0;
      const ASTEROID_SCALE_MIN = 0.4;
      const ASTEROID_SCALE_MAX = 1.2;
      const PLAYER_SMOOTHING = 0.08;
      const SHIP_DEPTH = 0;
      const SPAWN_DISTANCE = 20;
      const DESPAWN_DISTANCE = 0;
      const MAX_ASTEROIDS = 50;
      const MOVEMENT_RATIO = 2.0;

      const renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById("c"),
        antialias: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 5;

      scene.add(new THREE.AmbientLight(0xffffff, 1));
      const dirLight = new THREE.DirectionalLight(0xffffff, 20.8);
      dirLight.position.set(5, 8, 7);
      scene.add(dirLight);

      const clock = new THREE.Clock();

      let playerShip = null;
      const asteroids = [];
      let targetShipPosition = new THREE.Vector3(0, -1, SHIP_DEPTH);
      const mouseNDC = new THREE.Vector2();

      let isTouching = false;
      let touchStartPos = new THREE.Vector2();
      let touchStartShipPos = new THREE.Vector3();

      const loadingManager = new THREE.LoadingManager();
      const fbxLoader = new FBXLoader(loadingManager);
      const textureLoader = new THREE.TextureLoader(loadingManager);
      const instructionsDiv = document.getElementById("instructions");
      instructionsDiv.style.display = "block";

      const backgroundTexture = textureLoader.load(
        "./assets/background.png",
        (texture) => {
          scene.background = texture;
        },
        (xhr) => {},
        (error) => {
          console.error("Error loading background texture:", error);
          instructionsDiv.innerText = `Error loading background: assets/background.png. Check path/file.`;
          instructionsDiv.style.color = "red";
          instructionsDiv.style.display = "block";
        }
      );

      const shipModelPath = "./assets/Galactic_Soarer_0504175114_texture.fbx";

      fbxLoader.load(
        shipModelPath,
        (fbx) => {
          playerShip = fbx;
          playerShip.scale.setScalar(0.02);
          playerShip.rotation.x = Math.PI * 0.05;
          playerShip.position.set(
            targetShipPosition.x,
            targetShipPosition.y,
            SHIP_DEPTH
          );
          scene.add(playerShip);
        },
        (xhr) => {
          const percentLoaded = (xhr.loaded / xhr.total) * 100;
          if (!scene.background) {
            instructionsDiv.innerText = `Loading ship: ${Math.round(
              percentLoaded
            )}%`;
          }
        },
        (error) => {
          console.error("Error loading FBX model:", error);
          instructionsDiv.innerText = `Error loading ship: ${shipModelPath}. Check path and console.`;
          instructionsDiv.style.color = "red";
          instructionsDiv.style.display = "block";
        }
      );

      loadingManager.onLoad = () => {
        if (!instructionsDiv.innerText.startsWith("Error")) {
          instructionsDiv.style.display = "none";
        }
        setupInputListeners();
        animate();
      };

      loadingManager.onError = (url) => {
        console.error("There was an error loading " + url);
      };

      function makeAsteroid() {
        const RADIUS = 1;
        const SEGMENTS = 8;
        const geometry = new THREE.SphereGeometry(RADIUS, SEGMENTS, SEGMENTS);

        const noise3D = createNoise3D();
        const posAttr = geometry.attributes.position;
        const v = new THREE.Vector3();

        const OCTAVES = 3;
        const BASE_FREQ = 1.4;
        const BASE_AMP = 0.18;

        for (let i = 0; i < posAttr.count; i++) {
          v.fromBufferAttribute(posAttr, i).normalize();
          let n = 0,
            amp = 1,
            freq = BASE_FREQ;
          for (let o = 0; o < OCTAVES; o++) {
            n += amp * noise3D(v.x * freq, v.y * freq, v.z * freq);
            amp *= 0.5;
            freq *= 2.0;
          }
          v.multiplyScalar(RADIUS + n * BASE_AMP);
          posAttr.setXYZ(i, v.x, v.y, v.z);
        }

        posAttr.needsUpdate = true;
        geometry.computeVertexNormals();

        const mainMaterial = new THREE.MeshToonMaterial({
          color: 0xdd44aa,
          emissive: 0x110011,
          flatShading: true,
        });
        const mainAsteroid = new THREE.Mesh(geometry, mainMaterial);

        const outlineMaterial = new THREE.MeshBasicMaterial({
          color: 0x220022,
          side: THREE.BackSide,
        });
        const outlineMesh = new THREE.Mesh(geometry.clone(), outlineMaterial);
        const OUTLINE_SCALE = 1.06;
        outlineMesh.scale.set(OUTLINE_SCALE, OUTLINE_SCALE, OUTLINE_SCALE);
        mainAsteroid.add(outlineMesh);

        const speed = ASTEROID_SPEED;

        const dirX = 0;
        const dirY = 0;
        const dirZ = 1.0;

        const velocity = new THREE.Vector3(dirX, dirY, dirZ)
          .normalize()
          .multiplyScalar(speed);

        mainAsteroid.userData = {
          velocity: velocity,
          rotationSpeed: new THREE.Vector3(
            THREE.MathUtils.randFloat(-0.5, 0.5),
            THREE.MathUtils.randFloat(-0.5, 0.5),
            THREE.MathUtils.randFloat(-0.5, 0.5)
          ),
        };

        return mainAsteroid;
      }

      function setupInputListeners() {
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("touchstart", onTouchStart, { passive: false });
        window.addEventListener("touchmove", onTouchMove, { passive: false });
        window.addEventListener("touchend", onTouchEnd);
        window.addEventListener("touchcancel", onTouchEnd);
      }

      function screenToWorld(clientX, clientY) {
        const screenNDC = new THREE.Vector2();
        screenNDC.x = (clientX / window.innerWidth) * 2 - 1;
        screenNDC.y = -(clientY / window.innerHeight) * 2 + 1;

        const vector = new THREE.Vector3(screenNDC.x, screenNDC.y, 0.5);
        vector.unproject(camera);

        const dir = vector.sub(camera.position).normalize();
        const distance = (SHIP_DEPTH - camera.position.z) / dir.z;
        const worldPos = new THREE.Vector3();
        worldPos.copy(camera.position).add(dir.multiplyScalar(distance));
        return worldPos;
      }

      function clampTargetShipPosition() {
        const visibleHeight =
          2 *
          Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) *
          Math.abs(SHIP_DEPTH - camera.position.z);
        const visibleWidth = visibleHeight * camera.aspect;

        targetShipPosition.x = THREE.MathUtils.clamp(
          targetShipPosition.x,
          -visibleWidth / 2.2,
          visibleWidth / 2.2
        );
        targetShipPosition.y = THREE.MathUtils.clamp(
          targetShipPosition.y,
          -visibleHeight / 2.2,
          visibleHeight / 2.2
        );
        targetShipPosition.z = SHIP_DEPTH;
      }

      function updateTargetPositionFromScreenCoords(clientX, clientY) {
        mouseNDC.x = (clientX / window.innerWidth) * 2 - 1;
        mouseNDC.y = -(clientY / window.innerHeight) * 2 + 1;

        const vector = new THREE.Vector3(mouseNDC.x, mouseNDC.y, 0.5);
        vector.unproject(camera);

        const dir = vector.sub(camera.position).normalize();
        const distance = (SHIP_DEPTH - camera.position.z) / dir.z;

        targetShipPosition
          .copy(camera.position)
          .add(dir.multiplyScalar(distance));

        clampTargetShipPosition();
      }

      function onMouseMove(event) {
        updateTargetPositionFromScreenCoords(event.clientX, event.clientY);
      }

      function onTouchStart(event) {
        event.preventDefault();
        if (event.touches.length > 0 && !isTouching) {
          isTouching = true;
          const touch = event.touches[0];
          touchStartPos.set(touch.clientX, touch.clientY);
          if (playerShip) {
            touchStartShipPos.copy(playerShip.position);
          } else {
            touchStartShipPos.copy(targetShipPosition);
          }
        }
      }

      function onTouchMove(event) {
        event.preventDefault();
        if (!isTouching || event.touches.length === 0) return;

        const touch = event.touches[0];
        const currentTouchPos = new THREE.Vector2(touch.clientX, touch.clientY);

        const worldStartPos = screenToWorld(touchStartPos.x, touchStartPos.y);
        const worldCurrentPos = screenToWorld(
          currentTouchPos.x,
          currentTouchPos.y
        );

        const worldDelta = worldCurrentPos.sub(worldStartPos);

        targetShipPosition
          .copy(touchStartShipPos)
          .addScaledVector(worldDelta, MOVEMENT_RATIO);

        clampTargetShipPosition();
      }

      function onTouchEnd(event) {
        if (event.touches.length === 0) {
          isTouching = false;
        }
      }

      function spawnAsteroid() {
        if (asteroids.length >= MAX_ASTEROIDS) return;

        const asteroid = makeAsteroid();

        const spawnZ = camera.position.z - SPAWN_DISTANCE;

        const height =
          2 *
          Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) *
          Math.abs(spawnZ - camera.position.z);
        const width = height * camera.aspect;

        asteroid.position.set(
          THREE.MathUtils.randFloatSpread(width * 0.2),
          THREE.MathUtils.randFloatSpread(height * 0.2),
          spawnZ
        );

        const scale = THREE.MathUtils.randFloat(
          ASTEROID_SCALE_MIN,
          ASTEROID_SCALE_MAX
        );
        asteroid.scale.setScalar(scale);

        asteroid.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );

        scene.add(asteroid);
        asteroids.push(asteroid);
      }

      function updateAsteroids(deltaTime) {
        for (let i = asteroids.length - 1; i >= 0; i--) {
          const asteroid = asteroids[i];
          if (!asteroid.userData || !asteroid.userData.velocity) {
            continue;
          }
          const velocity = asteroid.userData.velocity;
          const rotSpeed = asteroid.userData.rotationSpeed;

          asteroid.position.addScaledVector(velocity, deltaTime);

          asteroid.rotation.x += rotSpeed.x * deltaTime;
          asteroid.rotation.y += rotSpeed.y * deltaTime;
          asteroid.rotation.z += rotSpeed.z * deltaTime;

          const despawnZ = camera.position.z + DESPAWN_DISTANCE;
          if (asteroid.position.z > despawnZ) {
            scene.remove(asteroid);
            asteroids.splice(i, 1);
          }
        }
      }

      function updatePlayerShip(deltaTime) {
        if (!playerShip) return;

        playerShip.position.lerp(targetShipPosition, PLAYER_SMOOTHING);

        const bankAmount = (targetShipPosition.x - playerShip.position.x) * 0.5;
        const tiltAmount = (targetShipPosition.y - playerShip.position.y) * 0.2;

        const targetQuaternion = new THREE.Quaternion();
        const baseRotationX = Math.PI * 0.05;

        const targetEuler = new THREE.Euler(
          baseRotationX - tiltAmount,
          0,
          -bankAmount,
          "XYZ"
        );
        targetQuaternion.setFromEuler(targetEuler);

        playerShip.quaternion.slerp(targetQuaternion, PLAYER_SMOOTHING * 1.5);
      }

      let timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE;

      function animate() {
        requestAnimationFrame(animate);

        const deltaTime = clock.getDelta();

        timeToNextSpawn -= deltaTime;
        if (timeToNextSpawn <= 0) {
          spawnAsteroid();
          timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE;
        }

        updateAsteroids(deltaTime);
        updatePlayerShip(deltaTime);

        renderer.render(scene, camera);
      }

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      if (!renderer.getContext()) {
        instructionsDiv.innerText = "WebGL is not supported by your browser!";
        instructionsDiv.style.color = "red";
        instructionsDiv.style.display = "block";
      }
    </script>
  </body>
</html>
