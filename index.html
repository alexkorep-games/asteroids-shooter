<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Asteroid Shooter</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: "Consolas", "Courier New", monospace; /* Pixel-like font */
        background-color: #000; /* Ensure body bg for contrast */
        color: white; /* Default text color */
      }
      canvas {
        display: block; /* Default, might be hidden initially */
      }
      /* --- Start Screen Styles --- */
      #startScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #000; /* Match body background */
        display: flex; /* Initially shown */
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 100; /* Above everything else */
        padding: 20px;
        box-sizing: border-box;
      }
      #startScreen h1 {
        font-size: 2.5em;
        margin-bottom: 30px;
        color: #0f0; /* Greenish title */
      }
      #startScreen button {
        /* General button styling for start screen */
        padding: 15px 30px;
        font-size: 1.5em;
        cursor: pointer;
        border: 2px solid #ccc;
        border-radius: 5px;
        color: white;
        font-family: "Consolas", "Courier New", monospace;
        transition: background-color 0.2s;
        margin-top: 20px; /* Spacing between buttons/elements */
      }
      #startScreen #loginButton {
        /* Specific styling if needed, inherits general */
        background-color: #4285f4; /* Google Blue */
        display: flex; /* Keep icon layout */
        align-items: center;
        gap: 10px; /* Space between icon and text */
      }
      #startScreen #loginButton:hover {
        background-color: #357ae8;
      }
      #startScreen #startGameButton {
        background-color: #4caf50; /* Green */
      }
      #startScreen #startGameButton:hover {
        background-color: #45a049;
      }
      #startScreen #logoutButton {
        background-color: #f44336; /* Red */
        font-size: 1.2em; /* Slightly smaller */
        padding: 10px 20px;
      }
      #startScreen #logoutButton:hover {
        background-color: #da190b;
      }
      #startScreen #loginButton img,
      #startScreen #loginButton svg {
        /* Style for Google icon */
        width: 24px;
        height: 24px;
      }
      #startScreen #userInfo {
        font-size: 1.2em;
        margin-bottom: 15px;
        color: #eee;
      }
      #startScreen #startScoreDisplay {
        font-size: 1.4em;
        margin-bottom: 20px;
        color: #0f0; /* Match title color */
      }
      #startScreen #loginError {
        margin-top: 20px;
        color: #ff4d4d; /* Red error text */
        font-size: 1.1em;
        display: none; /* Hidden by default */
      }

      /* --- Login Screen (Now Hidden by default, functionality moved to Start Screen) --- */
      #loginScreen {
        /* display: none; */ /* Hide original login screen, replaced by startScreen */
        /* Keep styles if needed for reference or fallback, but hide it */
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #000;
        display: none; /* Hide this element */
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 99;
        padding: 20px;
        box-sizing: border-box;
      }
      /* --- Game elements initially hidden --- */
      #c,
      #hud,
      #speedIndicator,
      #asteroidCounter,
      #instructions,
      #gameOverScreen {
        display: none;
      }
      /* Ensure cursor is default on start/game over, managed later */
      body.game-active {
        cursor: none;
      }
      body:not(.game-active) {
        cursor: default;
      }

      /* --- Existing Styles (Instructions, GameOver, HighScore, HUD, etc.) --- */
      #instructions {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: sans-serif;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px;
        border-radius: 3px;
        /* display: none; /* Controlled by JS */
        z-index: 10;
      }
      #gameOverScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8); /* Darker overlay */
        color: white;
        font-family: "Consolas", "Courier New", monospace; /* Match font */
        /* display: none; /* Controlled by JS */
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 20;
        cursor: default; /* Show default cursor over the overlay */
        padding: 20px;
        box-sizing: border-box;
      }
      #gameOverScreen h1 {
        margin-bottom: 15px;
        font-size: 3em;
        color: #ff4d4d; /* Red Game Over text */
        text-shadow: 2px 2px #a00;
      }
      #finalScore {
        font-size: 1.5em;
        margin-bottom: 25px;
        color: #eee;
      }
      #restartButton {
        padding: 12px 25px;
        font-size: 1.3em;
        cursor: pointer; /* Pointer specifically for the button */
        border: 2px solid #ccc;
        border-radius: 5px;
        background-color: #333; /* Darker button */
        color: #eee;
        margin-top: 30px; /* Space above button */
        font-family: "Consolas", "Courier New", monospace;
        transition: background-color 0.2s, color 0.2s;
      }
      #restartButton:hover {
        background-color: #eee;
        color: #333;
      }
      #highScoreContainer {
        margin-top: 30px;
        background-color: rgba(20, 20, 20, 0.7);
        padding: 15px 25px;
        border-radius: 8px;
        border: 1px solid #555;
        max-width: 400px; /* Increased width for name */
        width: 90%;
      }
      #highScoreContainer h2 {
        margin-top: 0;
        margin-bottom: 15px;
        color: #0f0; /* Greenish title */
        font-size: 1.4em;
        text-decoration: underline;
      }
      #highScoreList {
        list-style-type: decimal; /* Numbered list */
        padding-left: 30px; /* Indent numbers */
        margin: 0;
        text-align: left;
        font-size: 1.1em;
        max-height: 150px; /* Limit height */
        overflow-y: auto; /* Scroll if needed */
        color: #ddd;
      }
      #highScoreList li {
        margin-bottom: 5px;
        white-space: nowrap; /* Prevent names from wrapping */
        overflow: hidden;
        text-overflow: ellipsis; /* Add ... for long names */
      }
      #highScoreList .loading,
      #highScoreList .error {
        font-style: italic;
        color: #aaa;
        text-align: center;
        list-style: none; /* Remove bullet for status messages */
      }
      #hud {
        position: absolute;
        top: 15px;
        left: 15px;
        right: 15px;
        /* display: flex; */ /* Controlled by JS */
        justify-content: space-between;
        align-items: flex-start; /* Align items to the top */
        pointer-events: none; /* Allow clicking through HUD */
        z-index: 15;
        color: white;
        font-family: "Consolas", "Courier New", monospace; /* Consistent font */
      }
      #healthContainer {
        display: flex;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.5);
        padding: 5px 8px;
        border-radius: 4px;
        border: 1px solid rgba(255, 255, 255, 0.3);
      }
      #healthIcon {
        width: 20px;
        height: 20px;
        margin-right: 8px;
        position: relative;
        font-size: 18px;
        line-height: 20px;
      }
      #healthBarOuter {
        width: 150px;
        height: 15px;
        background-color: #444;
        border: 1px solid #666;
        border-radius: 3px;
        overflow: hidden;
      }
      #healthBarInner {
        height: 100%;
        width: 100%;
        background-color: #4caf50; /* Green */
        transition: width 0.3s ease, background-color 0.3s ease;
      }
      #asteroidCounter {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background-color: rgba(0, 0, 0, 0.5);
        padding: 8px 12px;
        border-radius: 4px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        font-size: 1.2em;
        color: #eee;
        z-index: 15;
        text-align: right;
        font-family: "Consolas", "Courier New", monospace;
        /* display: block; */ /* Controlled by JS */
      }
      #speedIndicator {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background-color: rgba(0, 0, 0, 0.5);
        padding: 8px 12px;
        border-radius: 4px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        font-size: 1.2em;
        color: #eee;
        z-index: 15;
        pointer-events: none;
        font-family: "Consolas", "Courier New", monospace;
        /* display: block; */ /* Controlled by JS */
      }
      /* --- End Existing Styles --- */
    </style>
  </head>
  <body>
    <!-- Start Screen (Replaces Login Screen) -->
    <div id="startScreen">
      <h1>Asteroid Shooter</h1>
      <div id="userInfo" style="display: none"></div>
      <!-- Placeholder for Welcome msg -->
      <div id="startScoreDisplay" style="display: none">Score: 0</div>
      <!-- Placeholder for start score -->

      <!-- Login Button (shown when logged out) -->
      <button id="loginButton" style="display: none">
        <svg
          version="1.1"
          xmlns="http://www.w3.org/2000/svg"
          width="24px"
          height="24px"
          viewBox="0 0 48 48"
        >
          <g>
            <path
              fill="#EA4335"
              d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"
            ></path>
            <path
              fill="#4285F4"
              d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"
            ></path>
            <path
              fill="#FBBC05"
              d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"
            ></path>
            <path
              fill="#34A853"
              d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"
            ></path>
            <path fill="none" d="M0 0h48v48H0z"></path>
          </g>
        </svg>
        Sign in with Google
      </button>

      <!-- Start Game Button (shown when logged in) -->
      <button id="startGameButton" style="display: none">Start Game</button>

      <!-- Logout Button (shown when logged in) -->
      <button id="logoutButton" style="display: none">Log Out</button>

      <!-- Login Error Display -->
      <div id="loginError" style="display: none"></div>
    </div>

    <!-- Login Screen (Original - Hidden, kept for reference if needed) -->
    <div id="loginScreen">
      <!-- Content moved or replaced by startScreen -->
    </div>

    <!-- Game Canvas -->
    <canvas id="c"></canvas>

    <!-- HUD Elements -->
    <div id="hud">
      <div id="healthContainer">
        <div id="healthIcon">‚ù§Ô∏è</div>
        <div id="healthBarOuter">
          <div id="healthBarInner"></div>
        </div>
      </div>
      <!-- Welcome message/logout moved to start screen -->
    </div>
    <div id="speedIndicator">üöÄ 0.0 m/sec</div>
    <div id="asteroidCounter">0 / 0 ‚òÑÔ∏è</div>

    <div id="instructions">Loading assets...</div>

    <div id="gameOverScreen">
      <h1>Game Over</h1>
      <div id="finalScore">Final Score: 0</div>
      <div id="highScoreContainer">
        <h2>Global Records</h2>
        <ol id="highScoreList">
          <li class="loading">Loading scores...</li>
        </ol>
      </div>
      <button id="restartButton">Restart Game</button>
    </div>

    <!-- ES Module Shims -->
    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <!-- Import Map -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.156.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.156.1/examples/jsm/",
          "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js",
          "firebase/app": "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js",
          "firebase/database": "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js",
          "firebase/auth": "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js"
        }
      }
    </script>

    <!-- Main Game Script -->
    <script type="module">
      import * as THREE from "three";
      import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
      import { createNoise3D } from "simplex-noise";
      // Import Firebase modules
      import { initializeApp } from "firebase/app";
      import {
        getDatabase,
        ref,
        push,
        serverTimestamp,
        query,
        orderByChild,
        limitToLast,
        get,
        remove,
        onValue,
      } from "firebase/database";
      import {
        getAuth,
        GoogleAuthProvider,
        signInWithPopup,
        onAuthStateChanged,
        signOut, // Optional: If you add a logout button
      } from "firebase/auth";

      // --- Firebase Configuration ---
      const firebaseConfig = {
        apiKey: "AIzaSyBoO3ZOL4QqxxtcyT4UDK9F09VjjBqXCQA", // DO NOT HARDCODE KEYS IN PRODUCTION - use environment variables or server-side handling
        authDomain: "retroglide.firebaseapp.com",
        databaseURL:
          "https://retroglide-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "retroglide",
        storageBucket: "retroglide.firebasestorage.app",
        messagingSenderId: "791505722362",
        appId: "1:791505722362:web:9b72f63d1bf3ee1740a243",
      };

      // Initialize Firebase
      let firebaseApp;
      let database;
      let auth; // Firebase Auth instance
      let googleProvider; // Google Auth Provider instance
      let highScoresRef;
      let currentUser = null; // Store the currently logged-in user info
      const HIGH_SCORE_COUNT = 10;

      try {
        firebaseApp = initializeApp(firebaseConfig);
        database = getDatabase(firebaseApp);
        auth = getAuth(firebaseApp); // Initialize Auth
        googleProvider = new GoogleAuthProvider(); // Initialize Google Provider
        highScoresRef = ref(database, "highscores");
        console.log("Firebase initialized successfully.");
      } catch (error) {
        console.error("Firebase initialization failed:", error);
        // Show error on start screen maybe?
        const loginErrorDiv = document.getElementById("loginError");
        if (loginErrorDiv) {
          loginErrorDiv.textContent =
            "Firebase initialization failed. High scores unavailable.";
          loginErrorDiv.style.display = "block"; // Show error on start screen
        }
        database = null;
        auth = null;
      }

      // --- Game Constants ---
      const ASTEROID_SPAWN_RATE = 3;
      const INITIAL_ASTEROID_SPEED = 20.0;
      const ASTEROID_SCALE_MIN = 0.4;
      const ASTEROID_SCALE_MAX = 1.2;
      const ASTEROID_BASE_RADIUS = 1.0;
      const ASTEROID_DESTRUCTION_DURATION = 0.2;
      const ASTEROID_FLASH_COLOR = new THREE.Color(0xffffff);
      const PLAYER_SMOOTHING = 0.08;
      const SHIP_DEPTH = 0;
      const SPAWN_DISTANCE = 140;
      const DESPAWN_DISTANCE = 0;
      const MAX_ASTEROIDS = 50;
      const MOVEMENT_RATIO = 2.0;
      const SHIP_COLLISION_RADIUS_FACTOR = 0.4;
      const SHIP_INITIAL_HEALTH = 100;
      const SHIP_COLLISION_DAMAGE = 10;
      const INVULNERABILITY_DURATION = 1.5;
      const PROJECTILE_SPEED = 100.0;
      const PROJECTILE_RADIUS = 0.1;
      const SHOT_COOLDOWN = 0.15;
      const MAX_PROJECTILES = 30;
      const PROJECTILE_DESPAWN_Z = -130;
      const INVULNERABILITY_FLASH_INTERVAL = 0.1;

      // --- Three.js Setup ---
      const canvas = document.getElementById("c");
      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 5;

      scene.add(new THREE.AmbientLight(0xffffff, 1));
      const dirLight = new THREE.DirectionalLight(0xffffff, 20.8);
      dirLight.position.set(5, 8, 7);
      scene.add(dirLight);

      const clock = new THREE.Clock();

      // --- Game State Variables ---
      let playerShip = null;
      const asteroids = [];
      const projectiles = [];
      let targetShipPosition = new THREE.Vector3(0, -1, SHIP_DEPTH);
      const mouseNDC = new THREE.Vector2();
      let isTouching = false;
      let isShooting = false;
      let touchStartPos = new THREE.Vector2();
      let touchStartShipPos = new THREE.Vector3();
      let timeSinceLastShot = 0;
      let timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE;
      let isGameOver = true; // Start in a non-game state
      let animationFrameId = null;
      let shipBoundingSphere = null;
      let playerHealth = SHIP_INITIAL_HEALTH;
      let asteroidsDestroyed = 0;
      let totalAsteroidsSpawned = 0;
      let isInvulnerable = false;
      let invulnerabilityTimer = 0;
      let shipOriginalMaterial = null;
      let asteroidSpeed = INITIAL_ASTEROID_SPEED;
      let timeSinceLastFlash = 0;
      let gameInitialized = false; // Flag to prevent multiple initializations
      let assetsLoaded = false; // Flag to track asset loading status

      // --- DOM Elements ---
      // const loginScreen = document.getElementById("loginScreen"); // No longer primary screen
      const startScreen = document.getElementById("startScreen");
      const userInfoDiv = document.getElementById("userInfo");
      const startScoreDisplayDiv = document.getElementById("startScoreDisplay");
      const loginButton = document.getElementById("loginButton");
      const startGameButton = document.getElementById("startGameButton");
      const logoutButton = document.getElementById("logoutButton");
      const loginErrorDiv = document.getElementById("loginError"); // Error display within startScreen
      const instructionsDiv = document.getElementById("instructions");
      const gameOverScreen = document.getElementById("gameOverScreen");
      const restartButton = document.getElementById("restartButton");
      const healthBarInner = document.getElementById("healthBarInner");
      const asteroidCounterDisplay = document.getElementById("asteroidCounter");
      const speedIndicatorDisplay = document.getElementById("speedIndicator");
      const finalScoreDisplay = document.getElementById("finalScore");
      const highScoreList = document.getElementById("highScoreList");
      const hud = document.getElementById("hud");

      // --- Loaders ---
      const loadingManager = new THREE.LoadingManager();
      const fbxLoader = new FBXLoader(loadingManager);
      const textureLoader = new THREE.TextureLoader(loadingManager);

      // --- Authentication Logic ---

      // Function to handle Google Sign-In
      const loginWithGoogle = async () => {
        if (!auth || !googleProvider) {
          loginErrorDiv.textContent = "Authentication service not available.";
          loginErrorDiv.style.display = "block";
          return;
        }
        loginErrorDiv.style.display = "none"; // Clear previous errors
        try {
          const result = await signInWithPopup(auth, googleProvider);
          // This will trigger the onAuthStateChanged listener below
          console.log("Sign-in successful:", result.user);
        } catch (error) {
          console.error("Google Sign-In Error:", error);
          loginErrorDiv.textContent = `Login failed: ${error.message}`;
          loginErrorDiv.style.display = "block";
        }
      };

      // Function to handle Sign-Out
      const logOut = async () => {
        if (!auth) {
          console.error("Auth service not available for logout.");
          return;
        }
        try {
          await signOut(auth);
          // This will trigger onAuthStateChanged
          console.log("Sign-out initiated.");
        } catch (error) {
          console.error("Sign-out error:", error);
          loginErrorDiv.textContent = `Logout failed: ${error.message}`;
          loginErrorDiv.style.display = "block";
        }
      };

      // Listen for Authentication State Changes
      onAuthStateChanged(auth, (user) => {
        // Always ensure start screen is visible initially when auth state changes
        startScreen.style.display = "flex";
        // Hide game elements when auth state changes, until game is started
        canvas.style.display = "none";
        hud.style.display = "none";
        speedIndicator.style.display = "none";
        asteroidCounter.style.display = "none";
        gameOverScreen.style.display = "none"; // Hide game over if showing
        instructionsDiv.style.display = "none"; // Hide instructions
        document.body.classList.remove("game-active"); // Use default cursor

        // Stop the game loop if it's running
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        isGameOver = true; // Treat auth change as needing a fresh start

        if (user) {
          // User is signed in
          currentUser = user;
          console.log(
            "User logged in:",
            currentUser.displayName,
            currentUser.uid
          );

          // Update Start Screen for logged-in user
          userInfoDiv.textContent = `Welcome, ${
            currentUser.displayName || "Player"
          }!`;
          userInfoDiv.style.display = "block";
          startScoreDisplayDiv.textContent = `Destroyed: 0`; // Show initial score 0
          startScoreDisplayDiv.style.display = "block";
          loginButton.style.display = "none";
          logoutButton.style.display = "block"; // Show logout
          startGameButton.style.display = "block"; // Show start game
          startGameButton.disabled = !assetsLoaded; // Enable start only if assets are loaded
          loginErrorDiv.style.display = "none"; // Hide errors

          // Initialize game assets ONLY if not already done
          if (!gameInitialized) {
            initializeGameAssets(); // Will set assetsLoaded flag on completion
          } else {
            startGameButton.disabled = !assetsLoaded; // Ensure button state is correct
          }
        } else {
          // User is signed out
          currentUser = null;
          console.log("User logged out.");

          // Update Start Screen for logged-out user
          userInfoDiv.style.display = "none";
          startScoreDisplayDiv.style.display = "none";
          loginButton.style.display = "flex"; // Show login button (use flex for icon)
          logoutButton.style.display = "none";
          startGameButton.style.display = "none";
          // loginErrorDiv might still be shown if there was a logout error etc.

          // Optional: Reset game state completely on logout (already handled by setting isGameOver = true)
          // gameInitialized = false; // Maybe allow re-init if assets need refresh? Let's keep them loaded.
          assetsLoaded = false; // Assets are loaded, but user needs to log in and THEN start
        }
      });

      // Attach login function to button
      loginButton.addEventListener("click", loginWithGoogle);
      // Attach logout function to button
      logoutButton.addEventListener("click", logOut);
      // Attach start game function to button
      startGameButton.addEventListener("click", () => {
        startScreen.style.display = "none"; // Hide start screen
        // Show game elements
        canvas.style.display = "block";
        hud.style.display = "flex"; // Use flex for layout
        speedIndicator.style.display = "block";
        asteroidCounter.style.display = "block";
        document.body.classList.add("game-active"); // Enable custom cursor etc.

        restartGame(); // Reset state and start the animation loop
      });

      // --- Initialization ---
      // Moved asset loading logic into a function called by onAuthStateChanged
      function initializeGameAssets() {
        if (gameInitialized) return; // Prevent double initialization
        gameInitialized = true;
        assetsLoaded = false; // Mark assets as not loaded yet
        startGameButton.disabled = true; // Disable button while loading

        instructionsDiv.style.display = "block";
        instructionsDiv.textContent = "Loading assets...";

        // Load Background
        textureLoader.load(
          "./assets/background.png",
          (texture) => {
            scene.background = texture;
          },
          undefined,
          (error) => {
            console.error("Error loading background texture:", error);
            instructionsDiv.innerText = `Error loading background. Check path/file.`;
            instructionsDiv.style.color = "red";
          }
        );

        // Load Ship Model
        fbxLoader.load(
          "./assets/Galactic_Soarer_0504175114_texture.fbx", // Ensure this path is correct
          (fbx) => {
            playerShip = fbx;
            playerShip.scale.setScalar(0.02);
            playerShip.rotation.x = Math.PI * 0.05;
            playerShip.position.set(
              targetShipPosition.x,
              targetShipPosition.y,
              SHIP_DEPTH
            );
            scene.add(playerShip);

            playerShip.traverse((child) => {
              if (child.isMesh && !shipOriginalMaterial) {
                shipOriginalMaterial = child.material;
              }
            });

            const box = new THREE.Box3().setFromObject(playerShip, true);
            shipBoundingSphere = new THREE.Sphere();
            box.getBoundingSphere(shipBoundingSphere);
            shipBoundingSphere.radius *= SHIP_COLLISION_RADIUS_FACTOR;
          },
          (xhr) => {
            const percentLoaded = (xhr.loaded / xhr.total) * 100;
            if (
              !scene.background &&
              !instructionsDiv.innerText.startsWith("Error")
            ) {
              instructionsDiv.innerText = `Loading ship: ${Math.round(
                percentLoaded
              )}%`;
            }
          },
          (error) => {
            console.error("Error loading FBX model:", error);
            instructionsDiv.innerText = `Error loading ship. Check path and console.`;
            instructionsDiv.style.color = "red";
          }
        );

        loadingManager.onLoad = () => {
          if (!instructionsDiv.innerText.startsWith("Error")) {
            instructionsDiv.style.display = "none";
          }
          assetsLoaded = true; // Mark assets as loaded
          // Enable start button only if user is logged in at this point
          if (currentUser) {
            startGameButton.disabled = false;
          }
          setupInputListeners();
          restartButton.addEventListener("click", restartGame); // Add listener for game over screen restart
          // DO NOT start game loop here automatically
          console.log("Assets loaded successfully.");
        };

        loadingManager.onError = (url) => {
          console.error("There was an error loading " + url);
          instructionsDiv.innerText = `Error loading: ${url}. Check console.`;
          instructionsDiv.style.color = "red";
          assetsLoaded = false; // Mark as failed
          startGameButton.disabled = true; // Ensure button stays disabled
        };
      }

      // Projectile Assets (defined outside init function as they don't rely on loaders)
      const projectileGeometry = new THREE.SphereGeometry(
        PROJECTILE_RADIUS,
        8,
        8
      );
      const projectileMaterial = new THREE.MeshBasicMaterial({
        color: 0xffff00,
      }); // Yellow

      // --- Firebase High Score Functions ---

      async function saveHighScore(score) {
        if (!database || !highScoresRef || score <= 0) {
          console.log("Database not available or score is zero, not saving.");
          return;
        }
        if (!currentUser) {
          console.log("User not logged in, cannot save score.");
          // Optionally inform the user they need to be logged in.
          return;
        }

        try {
          // 1. Push the new score with user info
          const newScore = {
            name: currentUser.displayName || "Anonymous", // Use display name, fallback
            userId: currentUser.uid,
            score: score,
            timestamp: serverTimestamp(),
          };
          await push(highScoresRef, newScore);
          console.log("Score saved for user:", currentUser.displayName, score);

          // 2. Trim the leaderboard (keep only the top HIGH_SCORE_COUNT)
          const scoresQuery = query(highScoresRef, orderByChild("score"));
          const snapshot = await get(scoresQuery);

          if (snapshot.exists()) {
            const scores = [];
            snapshot.forEach((childSnapshot) => {
              scores.push({ key: childSnapshot.key, ...childSnapshot.val() });
            });

            if (scores.length > HIGH_SCORE_COUNT) {
              const scoresToRemove = scores.length - HIGH_SCORE_COUNT;
              for (let i = 0; i < scoresToRemove; i++) {
                const keyToRemove = scores[i].key;
                await remove(ref(database, `highscores/${keyToRemove}`));
                console.log(`Removed low score entry: ${keyToRemove}`);
              }
            }
          }
        } catch (error) {
          console.error("Error saving or trimming high score:", error);
        }
      }

      async function fetchAndDisplayHighScores() {
        if (!database || !highScoresRef) {
          highScoreList.innerHTML =
            '<li class="error">High score service unavailable.</li>';
          return;
        }

        highScoreList.innerHTML = '<li class="loading">Loading scores...</li>';

        try {
          const scoresQuery = query(
            highScoresRef,
            orderByChild("score"),
            limitToLast(HIGH_SCORE_COUNT)
          );
          const snapshot = await get(scoresQuery);

          if (snapshot.exists()) {
            const scores = [];
            snapshot.forEach((childSnapshot) => {
              scores.push(childSnapshot.val());
            });

            scores.sort((a, b) => b.score - a.score); // Sort descending

            highScoreList.innerHTML = "";
            if (scores.length === 0) {
              highScoreList.innerHTML =
                '<li class="loading">No scores yet!</li>';
            } else {
              scores.forEach((scoreData, index) => {
                const li = document.createElement("li");
                const displayName = scoreData.name || "Anonymous"; // Handle missing names
                // Truncate long names visually via CSS (text-overflow: ellipsis)
                li.textContent = `${index + 1}. ${displayName}: ${
                  scoreData.score
                } pts`;
                li.title = `${displayName}: ${scoreData.score} pts`; // Tooltip for full name
                highScoreList.appendChild(li);
              });
            }
          } else {
            highScoreList.innerHTML = '<li class="loading">No scores yet!</li>';
          }
        } catch (error) {
          console.error("Error fetching high scores:", error);
          highScoreList.innerHTML =
            '<li class="error">Could not load scores.</li>';
        }
      }

      // --- Utility Functions ---
      // (Keep makeAsteroid, markAsteroidAsDying, updateSpeed, disposeObject)
      function makeAsteroid() {
        const RADIUS = ASTEROID_BASE_RADIUS;
        const SEGMENTS = 8;
        const geometry = new THREE.SphereGeometry(RADIUS, SEGMENTS, SEGMENTS);
        const noise3D = createNoise3D();
        const posAttr = geometry.attributes.position;
        const v = new THREE.Vector3();
        const OCTAVES = 3,
          BASE_FREQ = 1.4,
          BASE_AMP = 0.18;

        for (let i = 0; i < posAttr.count; i++) {
          v.fromBufferAttribute(posAttr, i).normalize();
          let n = 0,
            amp = 1,
            freq = BASE_FREQ;
          for (let o = 0; o < OCTAVES; o++) {
            n += amp * noise3D(v.x * freq, v.y * freq, v.z * freq);
            amp *= 0.5;
            freq *= 2.0;
          }
          v.multiplyScalar(RADIUS + n * BASE_AMP);
          posAttr.setXYZ(i, v.x, v.y, v.z);
        }
        posAttr.needsUpdate = true;
        geometry.computeVertexNormals();
        geometry.computeBoundingSphere();

        const mainMaterial = new THREE.MeshToonMaterial({
          color: 0xdd44aa,
          emissive: 0x110011,
          // flatShading: true,
        });
        const mainAsteroid = new THREE.Mesh(geometry, mainMaterial);
        mainAsteroid.userData.originalColor = mainMaterial.color.clone();

        const outlineMaterial = new THREE.MeshBasicMaterial({
          color: 0x220022,
          side: THREE.BackSide,
        });
        const outlineMesh = new THREE.Mesh(geometry.clone(), outlineMaterial);
        const OUTLINE_SCALE = 1.06;
        outlineMesh.scale.set(OUTLINE_SCALE, OUTLINE_SCALE, OUTLINE_SCALE);
        mainAsteroid.add(outlineMesh);
        outlineMesh.userData.originalColor = outlineMaterial.color.clone();

        const velocity = new THREE.Vector3(0, 0, 1)
          .normalize()
          .multiplyScalar(asteroidSpeed); // Use current asteroidSpeed

        mainAsteroid.userData = {
          ...mainAsteroid.userData,
          velocity: velocity,
          rotationSpeed: new THREE.Vector3(
            THREE.MathUtils.randFloat(-0.5, 0.5),
            THREE.MathUtils.randFloat(-0.5, 0.5),
            THREE.MathUtils.randFloat(-0.5, 0.5)
          ),
          boundingRadius: geometry.boundingSphere.radius,
          isAsteroid: true,
          isDying: false,
          dyingTimer: 0,
          originalScale: 1.0,
        };
        return mainAsteroid;
      }

      function markAsteroidAsDying(asteroid) {
        if (!asteroid || asteroid.userData.isDying) return; // Already dying

        asteroid.userData.isDying = true;
        asteroid.userData.dyingTimer = ASTEROID_DESTRUCTION_DURATION;
        // Store original scale if not already stored (should be set at spawn)
        if (asteroid.userData.originalScale === undefined) {
          asteroid.userData.originalScale = asteroid.scale.x;
        }

        // Flash Effect
        if (asteroid.material) {
          asteroid.material.color.copy(ASTEROID_FLASH_COLOR);
          asteroid.material.emissive.copy(ASTEROID_FLASH_COLOR);
        }
        if (asteroid.children[0] && asteroid.children[0].material) {
          asteroid.children[0].material.color.copy(ASTEROID_FLASH_COLOR);
        }

        // Increment counter only when an asteroid is marked for dying
        asteroidsDestroyed++;
        updateSpeed(); // Adjust speed for future asteroids
        updateUI(); // Update the counter display and potentially start screen score display
      }

      function updateSpeed() {
        // Increase speed based on the number of asteroids destroyed
        asteroidSpeed = INITIAL_ASTEROID_SPEED + asteroidsDestroyed * 1.5;
        // Update velocity for NEWLY spawned asteroids (existing ones keep their speed)
        // Also update UI speed indicator
        if (speedIndicatorDisplay.style.display !== "none") {
          speedIndicatorDisplay.textContent = `üöÄ ${asteroidSpeed.toFixed(
            1
          )} m/sec`;
        }
      }

      function disposeObject(obj) {
        if (!obj) return;
        if (obj.parent) obj.parent.remove(obj);
        else if (scene.children.includes(obj)) scene.remove(obj);

        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)) {
            obj.material.forEach((material) => {
              if (material.map) material.map.dispose();
              material.dispose();
            });
          } else {
            if (obj.material.map) obj.material.map.dispose();
            obj.material.dispose();
          }
        }
        while (obj.children.length > 0) {
          disposeObject(obj.children[0]);
        }
      }

      function updateUI() {
        // Update Health Bar (only if HUD is visible)
        if (hud.style.display !== "none") {
          const healthPercentage = Math.max(0, playerHealth); // Clamp at 0
          healthBarInner.style.width = healthPercentage + "%";

          if (healthPercentage <= 25) {
            healthBarInner.style.backgroundColor = "#ff4d4d"; // Red
          } else if (healthPercentage <= 50) {
            healthBarInner.style.backgroundColor = "#ffcc00"; // Yellow
          } else {
            healthBarInner.style.backgroundColor = "#4CAF50"; // Green
          }
        }

        // Update Asteroid Counter (only if visible)
        if (asteroidCounterDisplay.style.display !== "none") {
          asteroidCounterDisplay.textContent = `${asteroidsDestroyed}/${totalAsteroidsSpawned} ‚òÑÔ∏è`;
        }
        // Update Speed Indicator (called within updateSpeed)
        // updateSpeed(); // Call here or ensure it's called whenever speed might change

        // Update Start Screen Score Display (only if visible)
        if (startScreen.style.display !== "none") {
          startScoreDisplayDiv.textContent = `Destroyed: ${asteroidsDestroyed}`;
        }
      }

      // --- Input Handling ---
      function setupInputListeners() {
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("mousedown", onMouseDown);
        window.addEventListener("mouseup", onMouseUp);
        window.addEventListener("touchstart", onTouchStart, { passive: false });
        window.addEventListener("touchmove", onTouchMove, { passive: false });
        window.addEventListener("touchend", onTouchEnd);
        window.addEventListener("touchcancel", onTouchEnd);
      }
      function screenToWorld(clientX, clientY) {
        const screenNDC = new THREE.Vector2();
        screenNDC.x = (clientX / window.innerWidth) * 2 - 1;
        screenNDC.y = -(clientY / window.innerHeight) * 2 + 1;
        const vector = new THREE.Vector3(screenNDC.x, screenNDC.y, 0.5);
        vector.unproject(camera);
        const dir = vector.sub(camera.position).normalize();
        const distance = (SHIP_DEPTH - camera.position.z) / dir.z;
        const worldPos = new THREE.Vector3();
        worldPos.copy(camera.position).add(dir.multiplyScalar(distance));
        return worldPos;
      }
      function getVisibleWidth() {
        return getVisibleHeight() * camera.aspect;
      }
      function getVisibleHeight() {
        return (
          2 *
          Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) *
          Math.abs(SHIP_DEPTH - camera.position.z)
        );
      }
      function clampTargetShipPosition() {
        const visibleHeight = getVisibleHeight();
        const visibleWidth = getVisibleWidth();
        targetShipPosition.x = THREE.MathUtils.clamp(
          targetShipPosition.x,
          -visibleWidth / 2.2,
          visibleWidth / 2.2
        );
        targetShipPosition.y = THREE.MathUtils.clamp(
          targetShipPosition.y,
          -visibleHeight / 2.2,
          visibleHeight / 2.2
        );
        targetShipPosition.z = SHIP_DEPTH;
      }
      function updateTargetPositionFromScreenCoords(clientX, clientY) {
        mouseNDC.x = (clientX / window.innerWidth) * 2 - 1;
        mouseNDC.y = -(clientY / window.innerHeight) * 2 + 1;
        const vector = new THREE.Vector3(mouseNDC.x, mouseNDC.y, 0.5);
        vector.unproject(camera);
        const dir = vector.sub(camera.position).normalize();
        const distance = (SHIP_DEPTH - camera.position.z) / dir.z;
        targetShipPosition
          .copy(camera.position)
          .add(dir.multiplyScalar(distance));
        clampTargetShipPosition();
      }
      function onMouseMove(event) {
        if (isGameOver || !currentUser) return; // Also check if logged in & game active
        updateTargetPositionFromScreenCoords(event.clientX, event.clientY);
      }
      function onMouseDown(event) {
        if (isGameOver || !currentUser) return;
        if (event.button === 0) isShooting = true;
      }
      function onMouseUp(event) {
        if (event.button === 0) isShooting = false;
      }
      function onTouchStart(event) {
        if (isGameOver || !currentUser) return;
        event.preventDefault();
        isShooting = true;
        if (event.touches.length === 1 && !isTouching) {
          isTouching = true;
          const touch = event.touches[0];
          touchStartPos.set(touch.clientX, touch.clientY);
          if (playerShip) touchStartShipPos.copy(playerShip.position);
          else touchStartShipPos.copy(targetShipPosition);
        }
      }
      function onTouchMove(event) {
        if (isGameOver || !currentUser) return;
        event.preventDefault();
        if (isTouching && event.touches.length > 0) {
          const touch = event.touches[0];
          const currentTouchPos = new THREE.Vector2(
            touch.clientX,
            touch.clientY
          );
          const worldStartPos = screenToWorld(touchStartPos.x, touchStartPos.y);
          const worldCurrentPos = screenToWorld(
            currentTouchPos.x,
            currentTouchPos.y
          );
          const worldDelta = worldCurrentPos.sub(worldStartPos);
          targetShipPosition
            .copy(touchStartShipPos)
            .addScaledVector(worldDelta, MOVEMENT_RATIO);
          clampTargetShipPosition();
        }
      }
      function onTouchEnd(event) {
        if (event.touches.length === 0) {
          isShooting = false;
          isTouching = false;
        } else {
          let movementTouchStillActive = false;
          for (let i = 0; i < event.touches.length; i++) {
            movementTouchStillActive = true;
            break;
          }
          if (!movementTouchStillActive) isTouching = false;
          isShooting = true;
        }
      }

      // --- Spawning ---
      function spawnAsteroid() {
        if (isGameOver || asteroids.length >= MAX_ASTEROIDS) return; // Don't spawn if game over
        const asteroid = makeAsteroid();
        totalAsteroidsSpawned++;
        updateUI(); // Update total spawned count
        const spawnZ = camera.position.z - SPAWN_DISTANCE;
        const height = getVisibleHeight() / 2.2;
        const width = getVisibleWidth() / 2.2;
        asteroid.position.set(
          THREE.MathUtils.randFloatSpread(width),
          THREE.MathUtils.randFloatSpread(height),
          spawnZ
        );
        const scale = THREE.MathUtils.randFloat(
          ASTEROID_SCALE_MIN,
          ASTEROID_SCALE_MAX
        );
        asteroid.scale.setScalar(scale);
        asteroid.userData.originalScale = scale;
        asteroid.userData.boundingRadius *= scale;
        asteroid.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );
        scene.add(asteroid);
        asteroids.push(asteroid);
      }
      function spawnProjectile() {
        if (isGameOver || !playerShip || projectiles.length >= MAX_PROJECTILES)
          return; // Don't spawn if game over
        const projectile = new THREE.Mesh(
          projectileGeometry,
          projectileMaterial
        );
        const spawnOffset = new THREE.Vector3(0, 0, -1);
        spawnOffset.applyQuaternion(playerShip.quaternion);
        projectile.position.copy(playerShip.position).add(spawnOffset);
        const velocity = new THREE.Vector3(0, 0, -PROJECTILE_SPEED);
        projectile.userData = {
          velocity: velocity,
          boundingRadius: PROJECTILE_RADIUS,
          isProjectile: true,
        };
        scene.add(projectile);
        projectiles.push(projectile);
      }

      // --- Update Functions ---
      function updateAsteroids(deltaTime) {
        if (isGameOver) return; // Don't update if game over
        for (let i = asteroids.length - 1; i >= 0; i--) {
          const asteroid = asteroids[i];
          if (asteroid.userData.isDying) {
            asteroid.userData.dyingTimer -= deltaTime;
            if (asteroid.userData.dyingTimer <= 0) {
              disposeObject(asteroid);
              asteroids.splice(i, 1);
            } else {
              const scaleFactor = THREE.MathUtils.clamp(
                asteroid.userData.dyingTimer / ASTEROID_DESTRUCTION_DURATION,
                0,
                1
              );
              asteroid.scale.setScalar(
                asteroid.userData.originalScale * scaleFactor
              );
            }
            continue;
          }

          if (!asteroid.userData || !asteroid.userData.velocity) {
            console.warn("Asteroid missing user data, removing:", asteroid);
            disposeObject(asteroid);
            asteroids.splice(i, 1);
            continue;
          }
          const velocity = asteroid.userData.velocity;
          const rotSpeed = asteroid.userData.rotationSpeed;
          asteroid.position.addScaledVector(velocity, deltaTime);
          asteroid.rotation.x += rotSpeed.x * deltaTime;
          asteroid.rotation.y += rotSpeed.y * deltaTime;
          asteroid.rotation.z += rotSpeed.z * deltaTime;

          const despawnZ = camera.position.z + DESPAWN_DISTANCE;
          if (asteroid.position.z > despawnZ) {
            disposeObject(asteroid);
            asteroids.splice(i, 1);
          }
        }
      }
      function updateProjectiles(deltaTime) {
        if (isGameOver) return; // Don't update if game over
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const projectile = projectiles[i];
          if (!projectile.userData || !projectile.userData.velocity) {
            console.warn("Projectile missing user data, removing:", projectile);
            disposeObject(projectile);
            projectiles.splice(i, 1);
            continue;
          }
          const velocity = projectile.userData.velocity;
          projectile.position.addScaledVector(velocity, deltaTime);
          if (projectile.position.z < PROJECTILE_DESPAWN_Z) {
            disposeObject(projectile);
            projectiles.splice(i, 1);
          }
        }
      }
      function updatePlayerShip(deltaTime) {
        if (isGameOver || !playerShip) return; // Don't update if game over
        playerShip.position.lerp(targetShipPosition, PLAYER_SMOOTHING);
        if (shipBoundingSphere)
          shipBoundingSphere.center.copy(playerShip.position);

        const bankAmount = (targetShipPosition.x - playerShip.position.x) * 0.5;
        const tiltAmount = (targetShipPosition.y - playerShip.position.y) * 0.2;
        const targetQuaternion = new THREE.Quaternion();
        const baseRotationX = Math.PI * 0.05;
        const targetEuler = new THREE.Euler(
          baseRotationX - tiltAmount,
          0,
          -bankAmount,
          "XYZ"
        );
        targetQuaternion.setFromEuler(targetEuler);
        playerShip.quaternion.slerp(targetQuaternion, PLAYER_SMOOTHING * 1.5);

        // Handle invulnerability flashing
        if (isInvulnerable) {
          invulnerabilityTimer -= deltaTime;
          timeSinceLastFlash += deltaTime; // Accumulate time since last flash

          // Check if it's time to toggle visibility
          if (timeSinceLastFlash >= INVULNERABILITY_FLASH_INTERVAL) {
            playerShip.visible = !playerShip.visible; // Toggle visibility
            timeSinceLastFlash = 0; // Reset the flash timer
          }

          // Check if invulnerability has ended
          if (invulnerabilityTimer <= 0) {
            isInvulnerable = false;
            playerShip.visible = true; // Ensure ship is visible at the end
            timeSinceLastFlash = 0; // Reset timer just in case
          }
        } else {
          if (playerShip && !playerShip.visible) {
            // Check if playerShip exists
            playerShip.visible = true;
          }
        }
      }

      // --- Collision Detection ---
      function checkShipAsteroidCollision() {
        if (
          !playerShip ||
          !shipBoundingSphere ||
          isInvulnerable ||
          isGameOver ||
          !currentUser
        )
          return; // No collision if invulnerable, game over, or logged out

        for (let i = asteroids.length - 1; i >= 0; i--) {
          // Iterate backwards for safe removal
          const asteroid = asteroids[i];
          if (
            !asteroid.userData ||
            asteroid.userData.isDying ||
            asteroid.userData.boundingRadius === undefined
          )
            continue;

          const asteroidRadius = asteroid.userData.boundingRadius;
          const distance = playerShip.position.distanceTo(asteroid.position);

          if (distance < shipBoundingSphere.radius + asteroidRadius) {
            // Collision detected!
            playerHealth -= SHIP_COLLISION_DAMAGE;
            isInvulnerable = true;
            invulnerabilityTimer = INVULNERABILITY_DURATION;
            if (playerShip) playerShip.visible = true; // Ensure visible when invulnerability starts
            timeSinceLastFlash = 0; // Reset flash timer

            // Destroy the asteroid that hit the player
            markAsteroidAsDying(asteroid); // This also increments counter and updates UI

            updateUI(); // Update health bar immediately

            console.log("Ship hit! Health:", playerHealth);

            if (playerHealth <= 0) {
              gameOver();
            }
            // Only process one collision per frame
            break;
          }
        }
      }

      function checkProjectileAsteroidCollisions() {
        if (isGameOver || !currentUser) return; // Don't check if logged out or game over

        for (let i = projectiles.length - 1; i >= 0; i--) {
          const projectile = projectiles[i];
          if (!projectile.userData || !projectile.userData.velocity) continue;

          for (let j = asteroids.length - 1; j >= 0; j--) {
            const asteroid = asteroids[j];
            if (
              !asteroid.userData ||
              asteroid.userData.isDying ||
              !asteroid.userData.velocity
            )
              continue;

            const distance = projectile.position.distanceTo(asteroid.position);
            const collisionThreshold =
              projectile.userData.boundingRadius +
              asteroid.userData.boundingRadius;

            if (distance < collisionThreshold) {
              markAsteroidAsDying(asteroid); // Marks as dying, starts flash/shrink, increments counter, updates UI

              disposeObject(projectile);
              projectiles.splice(i, 1);
              break; // Projectile hit one asteroid, move to next projectile
            }
          }
        }
      }

      // --- Game Flow ---
      function gameOver() {
        console.log("Game Over! Final Score:", asteroidsDestroyed);
        isGameOver = true;
        isShooting = false;
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = null; // Important: clear the ID

        finalScoreDisplay.textContent = `Final Score: ${asteroidsDestroyed}`;
        gameOverScreen.style.display = "flex"; // Show game over screen
        // Hide game elements except game over screen
        canvas.style.display = "none";
        hud.style.display = "none";
        speedIndicator.style.display = "none";
        asteroidCounter.style.display = "none";
        document.body.classList.remove("game-active"); // Show default cursor

        if (playerShip) playerShip.visible = true; // Ensure ship is visible if it exists

        // Attempt to save score (checks internally if user is logged in) and display leaderboard
        saveHighScore(asteroidsDestroyed);
        fetchAndDisplayHighScores(); // Fetch scores for the game over screen
      }

      function restartGame() {
        // This function is called from the Start Game button AND the Restart button on Game Over screen
        if (!currentUser || !assetsLoaded) {
          console.log(
            "Cannot start/restart: User not logged in or assets not loaded."
          );
          // If called from game over, maybe show start screen again?
          gameOverScreen.style.display = "none";
          startScreen.style.display = "flex"; // Go back to start screen
          return;
        }

        console.log("Restarting game...");
        isGameOver = false; // Mark game as active
        isShooting = false;
        gameOverScreen.style.display = "none"; // Hide game over screen if visible
        startScreen.style.display = "none"; // Ensure start screen is hidden
        document.body.classList.add("game-active"); // Hide cursor again
        // Show necessary game elements
        canvas.style.display = "block";
        hud.style.display = "flex";
        speedIndicator.style.display = "block";
        asteroidCounter.style.display = "block";

        targetShipPosition.set(0, -1, SHIP_DEPTH);
        if (playerShip) {
          playerShip.position.copy(targetShipPosition);
          playerShip.quaternion.set(0, 0, 0, 1);
          playerShip.rotation.x = Math.PI * 0.05;
          playerShip.visible = true;
        }

        // Clear existing objects
        asteroids.forEach(disposeObject);
        asteroids.length = 0;
        projectiles.forEach(disposeObject);
        projectiles.length = 0;

        // Reset game state
        timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE;
        timeSinceLastShot = 0;
        playerHealth = SHIP_INITIAL_HEALTH;
        asteroidsDestroyed = 0;
        totalAsteroidsSpawned = 0;
        isInvulnerable = false;
        invulnerabilityTimer = 0;
        asteroidSpeed = INITIAL_ASTEROID_SPEED;

        updateUI(); // Reset UI elements (health, score counts)
        updateSpeed(); // Reset speed indicator based on initial speed

        startGame(); // Start the animation loop again
      }

      function startGame() {
        // This function only starts the animation loop. State reset happens in restartGame.
        if (!currentUser || isGameOver || animationFrameId || !assetsLoaded) {
          console.log(
            "Start conditions not met (logged in?, game over?, already running?, assets loaded?)"
          );
          return; // Don't start if not ready
        }
        console.log("Starting game loop");
        // isGameOver should be false already from restartGame
        // isShooting should be false already from restartGame
        // UI elements should be visible from restartGame
        // document.body.classList.add("game-active"); // Already done in restartGame
        // updateUI(); // Already done in restartGame
        animate(); // Start the loop
      }

      function animate() {
        // Stop if game over or user logs out or assets not loaded
        if (isGameOver || !currentUser || !assetsLoaded) {
          console.log(
            "Animation loop stopping (isGameOver/!currentUser/!assetsLoaded)."
          );
          if (animationFrameId) cancelAnimationFrame(animationFrameId); // Ensure cancellation
          animationFrameId = null; // Clear ID if stopped
          return;
        }
        animationFrameId = requestAnimationFrame(animate);

        const deltaTime = clock.getDelta();
        timeSinceLastShot += deltaTime;

        // Spawning
        timeToNextSpawn -= deltaTime;
        if (timeToNextSpawn <= 0) {
          spawnAsteroid();
          timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE;
        }
        if (isShooting && timeSinceLastShot >= SHOT_COOLDOWN) {
          spawnProjectile();
          timeSinceLastShot = 0;
        }

        // Updates
        updateAsteroids(deltaTime);
        updateProjectiles(deltaTime);
        updatePlayerShip(deltaTime);

        // Collisions
        checkProjectileAsteroidCollisions();
        checkShipAsteroidCollision(); // This checks for game over internally

        renderer.render(scene, camera);
      }

      // --- Event Listeners & Initial Check ---
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Initial WebGL check (optional but good)
      if (!renderer.getContext()) {
        startScreen.innerHTML = // Update start screen with error
          "<h1>Error</h1><p>WebGL is not supported by your browser!</p>";
        startScreen.style.display = "flex";
        // Hide everything else potentially?
      }

      // NOTE: Game initialization (asset loading) is now triggered by
      // the onAuthStateChanged listener after a successful login.
      // The game START (animation loop) is triggered by the "Start Game" button click.
      // The initial UI state (showing start screen) is handled by CSS and the onAuthStateChanged listener.
    </script>
  </body>
</html>
