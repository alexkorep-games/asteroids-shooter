<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Asteroid Dodger</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        /* cursor: none; /* Manage cursor visibility in JS */
      }
      canvas {
        display: block;
      }
      #instructions {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: sans-serif;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px;
        border-radius: 3px;
        display: none;
        z-index: 10;
      }
      #gameOverScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        font-family: sans-serif;
        display: none; /* Initially hidden */
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 20;
        cursor: default; /* Show default cursor over the overlay */
      }
      #gameOverScreen h1 {
        margin-bottom: 20px;
      }
      #restartButton {
        padding: 10px 20px;
        font-size: 1.2em;
        cursor: pointer; /* Pointer specifically for the button */
        border: none;
        border-radius: 5px;
        background-color: #eee;
        color: #333;
      }
      #restartButton:hover {
        background-color: #ddd;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <div id="instructions">Loading assets...</div>
    <div id="gameOverScreen">
      <h1>Game Over</h1>
      <button id="restartButton">Restart Game</button>
    </div>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.156.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.156.1/examples/jsm/",
          "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
      import { createNoise3D } from "simplex-noise";

      const ASTEROID_SPAWN_RATE = 3;
      const ASTEROID_SPEED = 5.0;
      const ASTEROID_SCALE_MIN = 0.4;
      const ASTEROID_SCALE_MAX = 1.2;
      const ASTEROID_BASE_RADIUS = 1.0; // Base radius used in geometry
      const PLAYER_SMOOTHING = 0.08;
      const SHIP_DEPTH = 0;
      const SPAWN_DISTANCE = 20;
      const DESPAWN_DISTANCE = 0;
      const MAX_ASTEROIDS = 50;
      const MOVEMENT_RATIO = 2.0;
      const SHIP_COLLISION_RADIUS_FACTOR = 0.4; // Adjust ship collision size

      const renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById("c"),
        antialias: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 5;

      scene.add(new THREE.AmbientLight(0xffffff, 1));
      const dirLight = new THREE.DirectionalLight(0xffffff, 20.8);
      dirLight.position.set(5, 8, 7);
      scene.add(dirLight);

      const clock = new THREE.Clock();

      let playerShip = null;
      const asteroids = [];
      let targetShipPosition = new THREE.Vector3(0, -1, SHIP_DEPTH);
      const mouseNDC = new THREE.Vector2();

      let isTouching = false;
      let touchStartPos = new THREE.Vector2();
      let touchStartShipPos = new THREE.Vector3();

      const loadingManager = new THREE.LoadingManager();
      const fbxLoader = new FBXLoader(loadingManager);
      const textureLoader = new THREE.TextureLoader(loadingManager);
      const instructionsDiv = document.getElementById("instructions");
      const gameOverScreen = document.getElementById("gameOverScreen");
      const restartButton = document.getElementById("restartButton");
      instructionsDiv.style.display = "block";

      let isGameOver = false;
      let animationFrameId = null;
      let shipBoundingSphere = null;

      // Set initial cursor state
      document.body.style.cursor = "none";

      const backgroundTexture = textureLoader.load(
        "./assets/background.png",
        (texture) => {
          scene.background = texture;
        },
        (xhr) => {},
        (error) => {
          console.error("Error loading background texture:", error);
          instructionsDiv.innerText = `Error loading background: assets/background.png. Check path/file.`;
          instructionsDiv.style.color = "red";
          instructionsDiv.style.display = "block";
        }
      );

      const shipModelPath = "./assets/Galactic_Soarer_0504175114_texture.fbx";

      fbxLoader.load(
        shipModelPath,
        (fbx) => {
          playerShip = fbx;
          playerShip.scale.setScalar(0.02);
          playerShip.rotation.x = Math.PI * 0.05;
          playerShip.position.set(
            targetShipPosition.x,
            targetShipPosition.y,
            SHIP_DEPTH
          );
          scene.add(playerShip);

          // Calculate bounding sphere after model is loaded and positioned
          const box = new THREE.Box3().setFromObject(playerShip, true); // true to traverse children
          shipBoundingSphere = new THREE.Sphere();
          box.getBoundingSphere(shipBoundingSphere);
          // Adjust radius if needed - FBX models might have complex origins
          shipBoundingSphere.radius *= SHIP_COLLISION_RADIUS_FACTOR;
        },
        (xhr) => {
          const percentLoaded = (xhr.loaded / xhr.total) * 100;
          if (!scene.background) {
            instructionsDiv.innerText = `Loading ship: ${Math.round(
              percentLoaded
            )}%`;
          }
        },
        (error) => {
          console.error("Error loading FBX model:", error);
          instructionsDiv.innerText = `Error loading ship: ${shipModelPath}. Check path and console.`;
          instructionsDiv.style.color = "red";
          instructionsDiv.style.display = "block";
        }
      );

      loadingManager.onLoad = () => {
        if (!instructionsDiv.innerText.startsWith("Error")) {
          instructionsDiv.style.display = "none";
        }
        setupInputListeners();
        restartButton.addEventListener("click", restartGame);
        startGame(); // Start the game initially
      };

      loadingManager.onError = (url) => {
        console.error("There was an error loading " + url);
      };

      function makeAsteroid() {
        const RADIUS = ASTEROID_BASE_RADIUS;
        const SEGMENTS = 8;
        const geometry = new THREE.SphereGeometry(RADIUS, SEGMENTS, SEGMENTS);

        const noise3D = createNoise3D();
        const posAttr = geometry.attributes.position;
        const v = new THREE.Vector3();

        const OCTAVES = 3;
        const BASE_FREQ = 1.4;
        const BASE_AMP = 0.18;

        for (let i = 0; i < posAttr.count; i++) {
          v.fromBufferAttribute(posAttr, i).normalize();
          let n = 0,
            amp = 1,
            freq = BASE_FREQ;
          for (let o = 0; o < OCTAVES; o++) {
            n += amp * noise3D(v.x * freq, v.y * freq, v.z * freq);
            amp *= 0.5;
            freq *= 2.0;
          }
          v.multiplyScalar(RADIUS + n * BASE_AMP);
          posAttr.setXYZ(i, v.x, v.y, v.z);
        }

        posAttr.needsUpdate = true;
        geometry.computeVertexNormals();
        geometry.computeBoundingSphere(); // Compute bounding sphere for the geometry

        const mainMaterial = new THREE.MeshToonMaterial({
          color: 0xdd44aa,
          emissive: 0x110011,
          flatShading: true,
        });
        const mainAsteroid = new THREE.Mesh(geometry, mainMaterial);

        const outlineMaterial = new THREE.MeshBasicMaterial({
          color: 0x220022,
          side: THREE.BackSide,
        });
        const outlineMesh = new THREE.Mesh(geometry.clone(), outlineMaterial);
        const OUTLINE_SCALE = 1.06;
        outlineMesh.scale.set(OUTLINE_SCALE, OUTLINE_SCALE, OUTLINE_SCALE);
        mainAsteroid.add(outlineMesh);

        const speed = ASTEROID_SPEED;

        const dirX = 0;
        const dirY = 0;
        const dirZ = 1.0;

        const velocity = new THREE.Vector3(dirX, dirY, dirZ)
          .normalize()
          .multiplyScalar(speed);

        // Store geometry's bounding sphere radius for collision checks
        mainAsteroid.userData = {
          velocity: velocity,
          rotationSpeed: new THREE.Vector3(
            THREE.MathUtils.randFloat(-0.5, 0.5),
            THREE.MathUtils.randFloat(-0.5, 0.5),
            THREE.MathUtils.randFloat(-0.5, 0.5)
          ),
          boundingRadius: geometry.boundingSphere.radius,
        };

        return mainAsteroid;
      }

      function setupInputListeners() {
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("touchstart", onTouchStart, { passive: false });
        window.addEventListener("touchmove", onTouchMove, { passive: false });
        window.addEventListener("touchend", onTouchEnd);
        window.addEventListener("touchcancel", onTouchEnd);
      }

      // Optional: Function to remove listeners if needed, though checking isGameOver is often sufficient
      // function removeInputListeners() {
      //     window.removeEventListener("mousemove", onMouseMove);
      //     window.removeEventListener("touchstart", onTouchStart);
      //     window.removeEventListener("touchmove", onTouchMove);
      //     window.removeEventListener("touchend", onTouchEnd);
      //     window.removeEventListener("touchcancel", onTouchEnd);
      // }

      function screenToWorld(clientX, clientY) {
        const screenNDC = new THREE.Vector2();
        screenNDC.x = (clientX / window.innerWidth) * 2 - 1;
        screenNDC.y = -(clientY / window.innerHeight) * 2 + 1;

        const vector = new THREE.Vector3(screenNDC.x, screenNDC.y, 0.5);
        vector.unproject(camera);

        const dir = vector.sub(camera.position).normalize();
        const distance = (SHIP_DEPTH - camera.position.z) / dir.z;
        const worldPos = new THREE.Vector3();
        worldPos.copy(camera.position).add(dir.multiplyScalar(distance));
        return worldPos;
      }

      function clampTargetShipPosition() {
        const visibleHeight =
          2 *
          Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) *
          Math.abs(SHIP_DEPTH - camera.position.z);
        const visibleWidth = visibleHeight * camera.aspect;

        targetShipPosition.x = THREE.MathUtils.clamp(
          targetShipPosition.x,
          -visibleWidth / 2.2,
          visibleWidth / 2.2
        );
        targetShipPosition.y = THREE.MathUtils.clamp(
          targetShipPosition.y,
          -visibleHeight / 2.2,
          visibleHeight / 2.2
        );
        targetShipPosition.z = SHIP_DEPTH;
      }

      function updateTargetPositionFromScreenCoords(clientX, clientY) {
        mouseNDC.x = (clientX / window.innerWidth) * 2 - 1;
        mouseNDC.y = -(clientY / window.innerHeight) * 2 + 1;

        const vector = new THREE.Vector3(mouseNDC.x, mouseNDC.y, 0.5);
        vector.unproject(camera);

        const dir = vector.sub(camera.position).normalize();
        const distance = (SHIP_DEPTH - camera.position.z) / dir.z;

        targetShipPosition
          .copy(camera.position)
          .add(dir.multiplyScalar(distance));

        clampTargetShipPosition();
      }

      function onMouseMove(event) {
        if (isGameOver) return;
        updateTargetPositionFromScreenCoords(event.clientX, event.clientY);
      }

      function onTouchStart(event) {
        if (isGameOver) return;
        event.preventDefault();
        if (event.touches.length > 0 && !isTouching) {
          isTouching = true;
          const touch = event.touches[0];
          touchStartPos.set(touch.clientX, touch.clientY);
          if (playerShip) {
            touchStartShipPos.copy(playerShip.position);
          } else {
            touchStartShipPos.copy(targetShipPosition);
          }
        }
      }

      function onTouchMove(event) {
        if (isGameOver) return;
        event.preventDefault();
        if (!isTouching || event.touches.length === 0) return;

        const touch = event.touches[0];
        const currentTouchPos = new THREE.Vector2(touch.clientX, touch.clientY);

        const worldStartPos = screenToWorld(touchStartPos.x, touchStartPos.y);
        const worldCurrentPos = screenToWorld(
          currentTouchPos.x,
          currentTouchPos.y
        );

        const worldDelta = worldCurrentPos.sub(worldStartPos);

        targetShipPosition
          .copy(touchStartShipPos)
          .addScaledVector(worldDelta, MOVEMENT_RATIO);

        clampTargetShipPosition();
      }

      function onTouchEnd(event) {
        if (event.touches.length === 0) {
          isTouching = false;
        }
      }

      function spawnAsteroid() {
        if (asteroids.length >= MAX_ASTEROIDS) return;

        const asteroid = makeAsteroid();

        const spawnZ = camera.position.z - SPAWN_DISTANCE;

        const height =
          2 *
          Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) *
          Math.abs(spawnZ - camera.position.z);
        const width = height * camera.aspect;

        // TODO make it fixed, not dependent on screen size
        asteroid.position.set(
          THREE.MathUtils.randFloatSpread(width * 0.3),
          THREE.MathUtils.randFloatSpread(height * 0.3),
          spawnZ
        );

        const scale = THREE.MathUtils.randFloat(
          ASTEROID_SCALE_MIN,
          ASTEROID_SCALE_MAX
        );
        asteroid.scale.setScalar(scale);
        // Update bounding radius based on scale
        asteroid.userData.boundingRadius *= scale;

        asteroid.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );

        scene.add(asteroid);
        asteroids.push(asteroid);
      }

      function updateAsteroids(deltaTime) {
        for (let i = asteroids.length - 1; i >= 0; i--) {
          const asteroid = asteroids[i];
          if (!asteroid.userData || !asteroid.userData.velocity) {
            continue;
          }
          const velocity = asteroid.userData.velocity;
          const rotSpeed = asteroid.userData.rotationSpeed;

          asteroid.position.addScaledVector(velocity, deltaTime);

          asteroid.rotation.x += rotSpeed.x * deltaTime;
          asteroid.rotation.y += rotSpeed.y * deltaTime;
          asteroid.rotation.z += rotSpeed.z * deltaTime;

          const despawnZ = camera.position.z + DESPAWN_DISTANCE;
          if (asteroid.position.z > despawnZ) {
            scene.remove(asteroid);
            // Dispose geometry and materials if needed for heavy scenes
            // asteroid.geometry.dispose();
            // asteroid.material.dispose(); // Check if material is shared
            asteroids.splice(i, 1);
          }
        }
      }

      function updatePlayerShip(deltaTime) {
        if (!playerShip) return;

        playerShip.position.lerp(targetShipPosition, PLAYER_SMOOTHING);

        // Update the bounding sphere's center to match the ship's current position
        if (shipBoundingSphere) {
          shipBoundingSphere.center.copy(playerShip.position);
        }

        const bankAmount = (targetShipPosition.x - playerShip.position.x) * 0.5;
        const tiltAmount = (targetShipPosition.y - playerShip.position.y) * 0.2;

        const targetQuaternion = new THREE.Quaternion();
        const baseRotationX = Math.PI * 0.05;

        const targetEuler = new THREE.Euler(
          baseRotationX - tiltAmount,
          0,
          -bankAmount,
          "XYZ"
        );
        targetQuaternion.setFromEuler(targetEuler);

        playerShip.quaternion.slerp(targetQuaternion, PLAYER_SMOOTHING * 1.5);
      }

      function checkCollisions() {
        if (!playerShip || !shipBoundingSphere) return false;

        for (let i = 0; i < asteroids.length; i++) {
          const asteroid = asteroids[i];
          if (
            !asteroid.userData ||
            asteroid.userData.boundingRadius === undefined
          )
            continue;

          // Simple sphere-sphere collision check
          const asteroidRadius = asteroid.userData.boundingRadius; // Already scaled in spawnAsteroid
          const distance = playerShip.position.distanceTo(asteroid.position);

          if (distance < shipBoundingSphere.radius + asteroidRadius) {
            return true; // Collision detected
          }
        }
        return false; // No collision
      }

      function gameOver() {
        isGameOver = true;
        cancelAnimationFrame(animationFrameId); // Stop the animation loop
        gameOverScreen.style.display = "flex"; // Show the game over screen
        document.body.style.cursor = "default"; // Show the cursor
        // Optional: removeInputListeners();
      }

      function restartGame() {
        isGameOver = false;
        gameOverScreen.style.display = "none"; // Hide the game over screen
        document.body.style.cursor = "none"; // Hide the cursor again

        // Reset ship position
        targetShipPosition.set(0, -1, SHIP_DEPTH);
        if (playerShip) {
          playerShip.position.copy(targetShipPosition);
          playerShip.quaternion.set(0, 0, 0, 1); // Reset rotation
          playerShip.rotation.x = Math.PI * 0.05; // Apply initial tilt
        }

        // Remove all existing asteroids
        for (let i = asteroids.length - 1; i >= 0; i--) {
          scene.remove(asteroids[i]);
          // Dispose geometry/material if needed
          // asteroids[i].geometry.dispose();
          // asteroids[i].material.dispose();
        }
        asteroids.length = 0; // Clear the array

        // Reset spawn timer
        timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE;

        // Reset clock if needed (usually getDelta handles this fine)
        // clock.start(); // Or clock.elapsedTime = 0;

        // Restart the animation loop
        // Optional: setupInputListeners(); // Re-add if removed in gameOver
        animate();
      }

      function startGame() {
        isGameOver = false;
        document.body.style.cursor = "none";
        animate();
      }

      let timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE;

      function animate() {
        if (isGameOver) return; // Don't continue if game is over

        animationFrameId = requestAnimationFrame(animate); // Store the frame ID

        const deltaTime = clock.getDelta();

        timeToNextSpawn -= deltaTime;
        if (timeToNextSpawn <= 0) {
          spawnAsteroid();
          timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE;
        }

        updateAsteroids(deltaTime);
        updatePlayerShip(deltaTime);

        if (checkCollisions()) {
          gameOver();
          return; // Stop this frame processing after game over
        }

        renderer.render(scene, camera);
      }

      window.addEventListener("resize", () => {
        if (isGameOver) return; // Don't resize things if game is over? Or maybe allow it.
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Recalculate clamping bounds if needed upon resize
        // clampTargetShipPosition(); // May need adjustment if called here
      });

      if (!renderer.getContext()) {
        instructionsDiv.innerText = "WebGL is not supported by your browser!";
        instructionsDiv.style.color = "red";
        instructionsDiv.style.display = "block";
        gameOverScreen.style.display = "none"; // Ensure game over isn't shown on WebGL error
      }
    </script>
  </body>
</html>
