<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Asteroid Dodger</title>
    <style>
      body {
        margin: 0;
        background: #000;
        overflow: hidden;
        cursor: none;
      }
      canvas {
        display: block;
      }
      #instructions {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: sans-serif;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px;
        border-radius: 3px;
        /* Initially hidden, shown on error */
        display: none;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <div id="instructions">Loading assets...</div>

    <!-- ES-module Shims for older browser compatibility (optional but good practice) -->
    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.156.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.156.1/examples/jsm/",
          "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
        }
      }
    </script>

    <script type="module">
      /* ---------- IMPORTS ---------- */
      import * as THREE from "three";
      import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
      import { createNoise3D } from "simplex-noise";

      /* ---------- GAME CONSTANTS ---------- */
      const ASTEROID_SPAWN_RATE = 12; // Asteroids per second
      const ASTEROID_SPEED = 5.0;
      const ASTEROID_SCALE_MIN = 0.4;
      const ASTEROID_SCALE_MAX = 1.2;
      const PLAYER_SMOOTHING = 0.08; // Lower values = smoother/slower follow
      const SHIP_DEPTH = -2; // How far the ship is relative to the world origin (0,0,0)
      const SPAWN_DISTANCE = 20; // How far away (negative Z) asteroids spawn relative to camera
      const DESPAWN_DISTANCE = 10; // How far *past* the camera (positive Z) asteroids get removed
      const MAX_ASTEROIDS = 50;

      /* ---------- CORE THREE.JS SETUP ---------- */
      const renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById("c"),
        antialias: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 5; // Move camera back slightly from origin

      // --- Lighting ---
      scene.add(new THREE.AmbientLight(0xffffff, 1)); // Adjust 0.5 intensity (0.0 to 1.0+)
      const dirLight = new THREE.DirectionalLight(0xffffff, 20.8); // Increased intensity to better match screenshot
      dirLight.position.set(5, 8, 7);
      scene.add(dirLight);

      const clock = new THREE.Clock();

      /* ---------- GAME OBJECTS & STATE ---------- */
      let playerShip = null;
      const asteroids = [];
      let targetShipPosition = new THREE.Vector3(0, -1, SHIP_DEPTH); // Initial target slightly below center
      const mouseNDC = new THREE.Vector2(); // Normalized Device Coordinates (-1 to +1)

      /* ---------- ASSET LOADING ---------- */
      const loadingManager = new THREE.LoadingManager();
      const fbxLoader = new FBXLoader(loadingManager);
      const instructionsDiv = document.getElementById("instructions");
      instructionsDiv.style.display = "block"; // Show loading message

      // --- Load Spaceship ---
      // *** NOTE: Make sure the FBX file is accessible at this path ***
      // You might need to host this file or adjust the path.
      // If running locally, place the 'assets' folder next to your HTML file.
      const shipModelPath = "./assets/Galactic_Soarer_0504175114_texture.fbx";

      fbxLoader.load(
        shipModelPath,
        (fbx) => {
          playerShip = fbx;
          playerShip.scale.setScalar(0.008); // Scale might need adjustment
          playerShip.rotation.x = Math.PI * 0.05; // Slight tilt up
          playerShip.position.set(
            targetShipPosition.x,
            targetShipPosition.y,
            SHIP_DEPTH
          ); // Initial position
          scene.add(playerShip);
          console.log("Ship loaded!");
        },
        (xhr) => {
          // Optional: Update loading progress
          const percentLoaded = (xhr.loaded / xhr.total) * 100;
          instructionsDiv.innerText = `Loading ship: ${Math.round(
            percentLoaded
          )}%`;
          console.log(percentLoaded + "% loaded");
        },
        (error) => {
          console.error("Error loading FBX model:", error);
          instructionsDiv.innerText = `Error loading ship: ${shipModelPath}. Check path and console.`;
          instructionsDiv.style.color = "red";
          // Keep the error message displayed
        }
      );

      loadingManager.onLoad = () => {
        console.log("All assets loaded");
        instructionsDiv.style.display = "none"; // Hide instructions on successful load
        setupInputListeners();
        animate(); // Start the game loop only after loading
      };

      loadingManager.onError = (url) => {
        console.error("There was an error loading " + url);
        // Error message is already handled in the fbxLoader's error callback
        // but you could add more generic handling here if needed.
      };

      /* ---------- ASTEROID GENERATION ---------- */
      function makeAsteroid() {
        const RADIUS = 1;
        const SEGMENTS = 8; // Low poly look
        const geometry = new THREE.SphereGeometry(RADIUS, SEGMENTS, SEGMENTS);

        const noise3D = createNoise3D();
        const posAttr = geometry.attributes.position;
        const v = new THREE.Vector3();

        const OCTAVES = 3;
        const BASE_FREQ = 1.4;
        const BASE_AMP = 0.18; // Controls bumpiness

        for (let i = 0; i < posAttr.count; i++) {
          v.fromBufferAttribute(posAttr, i).normalize();
          let n = 0,
            amp = 1,
            freq = BASE_FREQ;
          for (let o = 0; o < OCTAVES; o++) {
            n += amp * noise3D(v.x * freq, v.y * freq, v.z * freq);
            amp *= 0.5;
            freq *= 2.0;
          }
          v.multiplyScalar(RADIUS + n * BASE_AMP);
          posAttr.setXYZ(i, v.x, v.y, v.z);
        }

        posAttr.needsUpdate = true;
        geometry.computeVertexNormals();

        const mainMaterial = new THREE.MeshToonMaterial({
          // Toon material for flat shaded look
          color: 0xdd44aa, // Pink color from screenshot
          emissive: 0x110011, // Slight emissive glow
          flatShading: true, // Use flat shading explicitly with Toon
        });
        const mainAsteroid = new THREE.Mesh(geometry, mainMaterial);

        // --- Outline (optional, but helps the style) ---
        const outlineMaterial = new THREE.MeshBasicMaterial({
          color: 0x220022, // Darker outline color
          side: THREE.BackSide,
        });
        const outlineMesh = new THREE.Mesh(geometry.clone(), outlineMaterial);
        const OUTLINE_SCALE = 1.06; // How thick the outline is
        outlineMesh.scale.set(OUTLINE_SCALE, OUTLINE_SCALE, OUTLINE_SCALE);
        mainAsteroid.add(outlineMesh); // Add outline as child

        // --- Game Data ---
        const speed = ASTEROID_SPEED;

        // ** CORRECTED VELOCITY CALCULATION **
        // Calculate a direction vector aiming generally forward but with spread
        // We want Z to be positive (moving towards camera at z=5 from spawn at z=-25)
        const dirX = 0;
        const dirY = 0;
        const dirZ = 1.0; // Primarily move forward along Z

        const velocity = new THREE.Vector3(dirX, dirY, dirZ)
          .normalize() // Make it a unit direction vector
          .multiplyScalar(speed); // Apply the random speed

        mainAsteroid.userData = {
          velocity: velocity, // Store the corrected velocity
          rotationSpeed: new THREE.Vector3(
            THREE.MathUtils.randFloat(-0.5, 0.5),
            THREE.MathUtils.randFloat(-0.5, 0.5),
            THREE.MathUtils.randFloat(-0.5, 0.5)
          ),
        };

        return mainAsteroid;
      }

      /* ---------- INPUT HANDLING ---------- */
      function setupInputListeners() {
        window.addEventListener("mousemove", onPointerMove);
        window.addEventListener("touchmove", onPointerMove, { passive: false }); // Use passive: false if preventDefault is needed
        window.addEventListener("touchstart", onPointerMove, {
          passive: false,
        });
      }

      function onPointerMove(event) {
        // Prevent scrolling on touch devices
        if (event.type.startsWith("touch")) {
          event.preventDefault();
        }

        let clientX, clientY;
        if (event.touches && event.touches.length > 0) {
          clientX = event.touches[0].clientX;
          clientY = event.touches[0].clientY;
        } else {
          clientX = event.clientX;
          clientY = event.clientY;
        }

        // Convert mouse/touch position to Normalized Device Coordinates (-1 to +1)
        mouseNDC.x = (clientX / window.innerWidth) * 2 - 1;
        mouseNDC.y = -(clientY / window.innerHeight) * 2 + 1;

        // Project NDC to world space at the ship's depth
        // Create a temporary vector for projection calculation
        const vector = new THREE.Vector3(mouseNDC.x, mouseNDC.y, 0.5); // z=0.5 is arbitrary, between near/far
        vector.unproject(camera); // Project from screen space to world space

        // Calculate direction from camera to the unprojected point
        const dir = vector.sub(camera.position).normalize();

        // Calculate distance along this direction to intersect the ship's Z-plane
        const distance = (SHIP_DEPTH - camera.position.z) / dir.z;

        // Calculate the target world position on the ship's Z-plane
        // Use a *copy* of camera position to avoid modifying it
        targetShipPosition
          .copy(camera.position)
          .add(dir.multiplyScalar(distance));

        // Optional: Clamp ship movement to screen edges (adjust bounds as needed)
        // Calculate the visible size of the game area at the ship's depth
        const visibleHeight =
          2 *
          Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) *
          Math.abs(SHIP_DEPTH - camera.position.z); // Use abs distance from camera to ship plane
        const visibleWidth = visibleHeight * camera.aspect;

        // Clamp the target position (adjust the divisor for padding)
        targetShipPosition.x = THREE.MathUtils.clamp(
          targetShipPosition.x,
          -visibleWidth / 2.2,
          visibleWidth / 2.2
        );
        targetShipPosition.y = THREE.MathUtils.clamp(
          targetShipPosition.y,
          -visibleHeight / 2.2,
          visibleHeight / 2.2
        );
        // Ensure target Z stays at SHIP_DEPTH (important!)
        targetShipPosition.z = SHIP_DEPTH;
      }

      /* ---------- GAME LOGIC ---------- */
      function spawnAsteroid() {
        if (asteroids.length >= MAX_ASTEROIDS) return;

        const asteroid = makeAsteroid();

        // Calculate spawn position based on view frustum at SPAWN_DISTANCE *behind* camera
        const spawnZ = camera.position.z - SPAWN_DISTANCE; // e.g., 5 - 30 = -25

        const height =
          2 *
          Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) *
          Math.abs(spawnZ - camera.position.z); // Distance from camera to spawn plane
        const width = height * camera.aspect;

        asteroid.position.set(
          THREE.MathUtils.randFloatSpread(width * 0.2),
          THREE.MathUtils.randFloatSpread(height * 0.2),
          spawnZ // Spawn distance in front of camera (further negative Z)
        );

        const scale = THREE.MathUtils.randFloat(
          ASTEROID_SCALE_MIN,
          ASTEROID_SCALE_MAX
        );
        asteroid.scale.setScalar(scale);

        asteroid.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );

        scene.add(asteroid);
        asteroids.push(asteroid);
      }

      function updateAsteroids(deltaTime) {
        for (let i = asteroids.length - 1; i >= 0; i--) {
          const asteroid = asteroids[i];
          // Check if userData and velocity exist before accessing
          if (!asteroid.userData || !asteroid.userData.velocity) {
            console.warn("Asteroid missing userData or velocity", asteroid);
            continue; // Skip this asteroid if data is missing
          }
          const velocity = asteroid.userData.velocity;
          const rotSpeed = asteroid.userData.rotationSpeed;

          // Move based on velocity
          asteroid.position.addScaledVector(velocity, deltaTime);

          // Rotate
          asteroid.rotation.x += rotSpeed.x * deltaTime;
          asteroid.rotation.y += rotSpeed.y * deltaTime;
          asteroid.rotation.z += rotSpeed.z * deltaTime;

          // Despawn if past camera + despawn distance
          const despawnZ = camera.position.z + DESPAWN_DISTANCE; // e.g., 5 + 10 = 15
          if (asteroid.position.z > despawnZ) {
            // Make sure to remove outline which is a child
            scene.remove(asteroid);
            asteroids.splice(i, 1);
          }
        }
      }

      function updatePlayerShip(deltaTime) {
        if (!playerShip) return; // Don't update if not loaded yet

        // Smoothly interpolate ship's current position towards the target position
        playerShip.position.lerp(targetShipPosition, PLAYER_SMOOTHING);

        // Optional: Bank ship slightly based on horizontal movement difference
        const bankAmount = (targetShipPosition.x - playerShip.position.x) * 0.5; // Banking factor
        // Optional: Tilt ship slightly based on vertical movement difference
        const tiltAmount = (targetShipPosition.y - playerShip.position.y) * 0.2; // Tilting factor

        // Smooth rotation lerping looks better than setting directly
        const targetQuaternion = new THREE.Quaternion();
        const baseRotationX = Math.PI * 0.05; // Keep the slight default up-tilt

        // Create target Euler rotation (order matters: YXZ or XYZ often used for aircraft)
        // Z-rotation (roll/bank), X-rotation (pitch/tilt), Y-rotation (yaw - usually zero here)
        const targetEuler = new THREE.Euler(
          baseRotationX - tiltAmount,
          0,
          -bankAmount,
          "XYZ"
        );
        targetQuaternion.setFromEuler(targetEuler);

        // Spherically interpolate the ship's current quaternion towards the target quaternion
        playerShip.quaternion.slerp(targetQuaternion, PLAYER_SMOOTHING * 1.5); // Rotate slightly faster than position lerp
      }

      /* ---------- RENDER LOOP ---------- */
      let timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE; // Start ready to spawn

      function animate() {
        requestAnimationFrame(animate); // Loop animation

        const deltaTime = clock.getDelta();

        // --- Spawn new asteroids ---
        timeToNextSpawn -= deltaTime;
        if (timeToNextSpawn <= 0) {
          spawnAsteroid();
          timeToNextSpawn = 1.0 / ASTEROID_SPAWN_RATE; // Reset timer
        }

        // --- Update game objects ---
        updateAsteroids(deltaTime);
        updatePlayerShip(deltaTime); // Update player ship movement and rotation

        // --- Render scene ---
        renderer.render(scene, camera);
      }

      /* ---------- HANDLE RESIZES ---------- */
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Clamping bounds in onPointerMove will automatically adjust due to camera.aspect change
      });

      // Initial check for WebGL support
      if (!renderer.getContext()) {
        instructionsDiv.innerText = "WebGL is not supported by your browser!";
        instructionsDiv.style.color = "red";
        instructionsDiv.style.display = "block"; // Ensure it's visible
      }
    </script>
  </body>
</html>
